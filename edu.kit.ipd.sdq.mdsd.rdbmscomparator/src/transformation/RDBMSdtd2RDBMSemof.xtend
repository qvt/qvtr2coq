package transformation

import java.util.ArrayList
import java.util.HashMap
import java.util.Map
import org.eclipse.emf.ecore.EObject
import rdbms.RDBMS
import rdbms.column
import rdbms.foreignKey
import rdbms.key
import rdbms.schema
import rdbms.table
import rdbmsMM.Column
import rdbmsMM.ForeignKey
import rdbmsMM.Key
import rdbmsMM.RdbmsMMFactory
import rdbmsMM.Schema
import rdbmsMM.Table

/**
 * Converts proprietary RDBMS models serialized by Haskell's HXT library to RDBMS.ecore models (the variant from the ModelMorf example).
 * The source format is a direct representation of the output model as specified in Coq (and automatically extracted to Haskell).
 * After it is generated by the Coq-proven UML2RDBMS transformation (which has been automatically extracted from the Coq proof, as well), it is stored under Haskell.
 * NOTE: This transformation is slightly more complicated than a simple 1:1 mapping, since
 * 		* reverse references must be reconstructed, and 
 * 		* weak references (unrolled to containment references) must be restored. 
 * 
 * @author Andreas Rentschler
 * @date 2015-12-23
 */
class RDBMSdtd2RDBMSemof {
	//val output = new ArrayList<EObject>
	val factory = RdbmsMMFactory.eINSTANCE
	
	def transform(/*Resource*/EObject input, Map<String, String> config) {
		val output = (input as RDBMS)?.mapRdbms2Dummy as EObject
		//output += input.contents.filter(RDBMSType).map[mapRdbms2Dummy]
		deferredActions.forEach[run]
		output
	}
	
	def create result:factory.createdummy mapRdbms2Dummy(RDBMS self_) {
		result.containsSchema += self_.schemas.schema.map[mapSchema2Schema]
	}
	
	def create result:factory.createSchema mapSchema2Schema(schema self_) {
		schemas.put(Integer.parseInt(self_.getOID), result)
		result.name = self_.name
		result.table += self_.tables.table.map[mapTable2Table]
		result.foreignKey += self_.foreignKeys.foreignKey.map[mapForeignKey2ForeignKey]
	}
	
	def create result:factory.createTable mapTable2Table(table self_) {
		tables.put(Integer.parseInt(self_.getOID), result)
		result.name = self_.name
		// result.schema => reverse/container reference not in Coq/DTD, but Ecore's EOpposite references are automatically set
		result.column += self_.columns.column.map[mapColumn2Column]
		result.hasKey = self_.key2.key.mapKey2Key
		// result.hasForeignKey => forward reference not in Coq/DTD but reverse reference, must set Ecore's EOpposite references so this reference is set automatically
	}

	def create result:factory.createColumn mapColumn2Column(column self_) {
		columns.put(Integer.parseInt(self_.getOID), result)
		result.name = self_.name
		result.type = self_.type
		// result.owner => reverse/container reference not in Coq/DTD, but Ecore's EOpposite references are automatically set
		// result.hasKey => forward reference not in Coq/DTD but reverse reference, must set Ecore's EOpposite references so this reference is set automatically
		// result.hasForeignKey => forward reference not in Coq/DTD but reverse reference, must set Ecore's EOpposite references so this reference is set automatically
	}

	def create result:factory.createKey mapKey2Key(key self_) {
		keys.put(Integer.parseInt(self_.getOID), result)
		result.name = self_.name
		// result.owner => reverse/container reference not in Coq/DTD, but Ecore's EOpposite references are automatically set
		deferredActions += [ result.column += self_.referencedColumns.OID.map[e | columns.get(Integer.parseInt(e.OID))].filterNull ]  // TODO: Check this mismatch - Coq has 1 and ModelMorf * Key.column
		// result.referedBy => reverse reference not in Coq/DTD, but Ecore's EOpposite references are automatically set
	}
	
	def create result:factory.createForeignKey mapForeignKey2ForeignKey(foreignKey self_) {
		foreignKeys.put(Integer.parseInt(self_.getOID), result)
		result.name = self_.name
		deferredActions += [ result.column += self_.referencedColumns.OID.map[e | columns.get(Integer.parseInt(e.OID))].filterNull ]
		// result.owner => forward reference not in Coq/DTD but reverse reference, must set Ecore's EOpposite references so this reference is set automatically
		deferredActions += [ result.owner = tables.get(Integer.parseInt(self_.owner)) ]
		deferredActions += [ result.refersTo = keys.get(Integer.parseInt(self_.refersTo)) ]
	}
	
	// In Coq/DTD, OIDs are unique numbers per type used for cross referencing.
	// When translating RDBMS from Coq/DTD to ModelMorf/Ecore, we must get an object for an OID.
	var schemas = new HashMap<Integer, Schema>()
	var tables = new HashMap<Integer, Table>()
	var columns = new HashMap<Integer, Column>()
	var keys = new HashMap<Integer, Key>()
	var foreignKeys = new HashMap<Integer, ForeignKey>()

	// Objects corresponding to OIDs might be created after reference, and must be executed after all objects are created.
	var deferredActions = new ArrayList<Runnable>
}