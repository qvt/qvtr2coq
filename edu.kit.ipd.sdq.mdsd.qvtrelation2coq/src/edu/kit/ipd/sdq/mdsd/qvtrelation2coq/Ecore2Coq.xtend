package edu.kit.ipd.sdq.mdsd.qvtrelation2coq

import java.text.SimpleDateFormat
import java.util.Date
import java.util.List
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EDataType
import org.eclipse.emf.ecore.EEnum
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature

// Map Ecore concepts to Coq concepts
// cf.	http://www.kermeta.org/docs/org.kermeta.ecore.documentation/build/html.chunked/Ecore-MDK/ch02.html
// 		for an Ecore metamodel diagram depicting the most important concepts
// cf.	Calegari et al.: Experiment with a Type-Theoretic Approach to the Verification of Model Transformations
class Ecore2Coq {
	
	// Entry point
	def mapModel(EPackage ePackage) '''
		(********************************************************************
		   @name Coq definitions for metamodel «ePackage.name»
		   @date «new SimpleDateFormat("yyyy/MM/dd HH:mm:ss").format(new Date)»
		   @description Automatically generated by QVTrelation2Coq transformation.
		   @see QVT-R Specification, Eclipse QVTd project, and the Coq Project.
		 ********************************************************************)

		Section «ePackage.name».
		
		(* Coq libraries *)
		Require Import List.
		Require Import String.
		Require Import Arith.
		Require Import Bool.

		(********************************************************************)
		(* EEnums: need to be defined first. *)
		«FOR eEnum : ePackage.EClassifiers.filter(typeof(EEnum))»
		Inductive «eEnum.mapClassifier» : Set := 
			«FOR eLiteral : eEnum.ELiterals AFTER '\t.\n'»
				| «eLiteral.name» : «eEnum.mapClassifier»
			«ENDFOR»
		«ENDFOR»

		(********************************************************************)
		(* EClasses: defined by constructors of an ID, local attributes and references. *)«
		/* Definitions are sorted by dependencies wrt. contained and inherited types, to ensure that definitions do not require yet undefined types.*/
		/* Concrete classes have records for their OIDs */
		val eClasses = ePackage.allClasses.sortByContainmentAndInheritanceDependencies»

		«FOR eClass : eClasses.concreteClasses»
			Record «eClass.mapClassifier»_OID : Set := Build_«eClass.mapClassifier»_OID { 
				Project_«eClass.mapClassifier»_OID_nat : nat 
			}.
		«ENDFOR»

		«FOR eClass : eClasses»
			Record «eClass.name» : Set := Build_«eClass.mapClassifier» {
				«eClass.mapClassAttributesToConstructor»
			}.
		«ENDFOR»
		
		Record «ePackage.name» := Build {
			«IF ePackage.rootClasses().size != 1»
				(* WARNING: There should be exactly one class contained nowhere else forming the root element! *)
				(* Taking the first from: «FOR eClass : ePackage.rootClasses SEPARATOR ', '»«eClass.name»«ENDFOR» *)
			«ENDIF»
			Content : list «
			FOR eClass : ePackage.rootClasses
			BEFORE if (ePackage.rootClasses.size > 1) '(' else ''
			SEPARATOR ' + '
			AFTER if (ePackage.rootClasses.size > 1) ')' else ''»«
			eClass.mapClassifier»«
			ENDFOR»
		}.
		
		(********************************************************************)
		(* EStructuralFeatures: projections of inherited attributes. *)
		
		«FOR eClass : eClasses»
		«eClass.mapInheritedClassAttributesToProjections»
		«ENDFOR»
		
		(********************************************************************)
		(* EAllInstances: Collecting all instances of a certain type in a model. *)

		«/*TODO: find out if we need all instances for an abstract type?*/
		FOR eClass : eClasses.concreteClasses.reverse»
		«eClass.mapClassToAllInstancesFunction(ePackage)»
		«ENDFOR»

		(********************************************************************)
		(* EReference[containment = false]: Resolving forward cross references (=> resolve OID). *)

		«FOR eClass : eClasses.concreteClasses»
		«eClass.mapClassToDereferenceFunction(ePackage)»
		«ENDFOR»
		
		«FOR eClass : eClasses.concreteClasses»
		«eClass.mapForwardCrossReferences(ePackage)»
		«ENDFOR»

		(********************************************************************)
		(* EReference[containment = false]: Resolving backward cross references *)

		«FOR eClass : eClasses.concreteClasses»
		«eClass.mapBackwardCrossReferences(ePackage)»
		«ENDFOR»

		(********************************************************************)
		(* EReference[containment = true]: Backward reference on containment hierarchy *)
		
		«FOR eClass : eClasses.concreteClasses»
		«eClass.mapBackwardContainmentReferences(ePackage)»
		«ENDFOR»

		(********************************************************************)
		(* Hypotheses *)
		(* OIDs are unique within an instance of this model per type. *)
		(* Note that, if we are being given this as an input model, we can 
		   declare this an axiom. For models we are generating, we will 
		   need to keep this as a hypothesis, so that we will keep it
		   as a proof obligation for the transformation proof. *)
		
		«FOR eClass : eClasses.concreteClasses.reverse»
		«eClass.mapClassToHypothesis(ePackage)»
		«ENDFOR»

		End «ePackage.name».
	'''
	
	// Topologically sort a list of classes, so that if a class A references or inherits from a class B, class B appears prior to class A in list 
	def List<EClass> sortByContainmentAndInheritanceDependencies(Iterable<EClass> classes) { 
		// Merge sort does not work for partial ordered lists, we need a topological sorting algorithm...
//		classes.sort(e1, e2 |
//			if ((e1.contains(e2) || e1.inherits(e2)) && !(e2.contains(e1) || e2.inherits(e1))) 1 else
//			if (!(e1.contains(e2) || e1.inherits(e2)) && (e2.contains(e1) || e2.inherits(e1))) -1 else 0
//		)
		if (classes.empty) return emptyList
		val independentClasses = classes.filter(e1 | !classes.exists(e2 | e1.contains(e2) || e1.inherits(e2))).toList
		if (independentClasses.empty) throw new Exception("Cannot topologically sort a graph with cycles!")
		val dependentClasses = classes.filter(e | !independentClasses.contains(e))
		independentClasses.addAll(dependentClasses.sortByContainmentAndInheritanceDependencies)
		independentClasses
	}
	
	// Helper functions evaluating if one class contains, references or inherits from another class
	def references(EClass from, EClass to) {
//		println(from.name + (
//			if (from.EAllReferences.map[EReferenceType].exists(e | e == to || to.EAllSuperTypes.contains(e))) " references " else " not references "
//		) + to.name)
		return from.EAllReferences.map[EReferenceType].exists(e | e == to || to.EAllSuperTypes.contains(e))
	}
	def contains(EClass from, EClass to) {
//		println(from.name + (
//			if (from.EAllContainments.map[EReferenceType].exists(e | e == to || to.EAllSuperTypes.contains(e))) " contains " else " not contains "
//		) + to.name)
		return from.EAllContainments.map[EReferenceType].exists(e | e == to || to.EAllSuperTypes.contains(e))
	}
	def inherits(EClass from, EClass to) {
//		println(from.name + (
//			if (from.EAllSuperTypes.contains(to)) " inherits " else " not inherits "
//		) + to.name)
		return from.EAllSuperTypes.contains(to)
	}
	
	// Helper function that finds those references that serve as a container for a given class 
	def containingReferences(EClass eClass) {
		eClass.allClasses.map[EAllContainments].flatten.filter[e | e.EReferenceType == eClass || eClass.EAllSuperTypes.contains(e.EReferenceType)].toList
	}

	// Helper function that filters those classes from a list that are not contained by others directly or as a super type in the list
	def rootClasses(EPackage ePackage) {
		val eConcreteClasses = ePackage.allClasses.filter(e | !e.abstract && !e.interface)
		eConcreteClasses.filter(e | !eConcreteClasses.exists(e2 | e2.contains(e))).toList
	}
	
	// Helper function that filters those classes from a list that are not abstract or an interface
	def concreteClasses(List<EClass> eClasses) {
		eClasses.filter(e | !e.interface && !e.abstract).toList
	}
	
	// For an EClass, compute all Coq attributes of a Coq class:
	// * locally (EStructuredFeatures()) contained attributes and references, no inherited onces (EAllStructuredFeatures()). 
	// * If a class is refined later on, the (possibly abstract) super class requires an additional parameter of one of the concrete subclasses. 
	//   This is because in a transformation rule, only after the subclass is created, inherited values can be set (via where or when). 
	//   So, we first construct a Female|Male and then a Person from it, in order to omit Coinductive types. 
	def mapClassAttributesToConstructor(EClass eClass) '''«
		// All concrete classes have an ID
		IF !eClass.abstract && !eClass.interface»
			Project_«eClass.mapClassifier»_oid : «eClass.name»_OID«
			if (eClass.ESuperTypes.empty && eClass.forwardReferences.empty) '' else ';'»«
		ENDIF»«
		
		// All interfaces and superclasses this class implements/extends
		FOR eSuperType : eClass.ESuperTypes
		SEPARATOR ';' 
		AFTER if (eClass.forwardReferences.empty) '' else ';'»
			Project_«eClass.mapClassifier»_«eSuperType.name.toFirstLower» : «eSuperType.mapClassifier»«
		ENDFOR»«
		
		// All local attributes including references
		FOR eReference : eClass.forwardReferences SEPARATOR ';'»
			Project_«eClass.mapClassifier»_«eReference.name.toFirstLower» : «eReference.mapStructuralFeature»«
		ENDFOR»«
		// Backward references are computed
		FOR eReference : eClass.backwardReferences»
			(*Project_«eClass.mapClassifier»_«eReference.name.toFirstLower» : «eReference.mapStructuralFeature»;*)«
		ENDFOR»
	'''
	
	// Helper function that computes all local forward references
	def forwardReferences(EClass eClass) {
		eClass.EStructuralFeatures.filter[containmentReference || crossReference]//.filter(EReference)
	}
	// Helper function that computes all local backward references
	def backwardReferences(EClass eClass) {
		eClass.EStructuralFeatures.filter[oppositeContainmentReference || oppositeCrossReference].filter(EReference)
	}
	// Helper function that computes all local and inherited forward containment references
	def forwardContainmentReferences(EClass eClass) {
		eClass.EAllStructuralFeatures.filter[containmentReference].filter(EReference)
	}
	// Helper function that computes all local and inherited backward containment references
	def backwardContainmentReferences(EClass eClass) {
		eClass.EAllStructuralFeatures.filter[oppositeContainmentReference].filter(EReference)
	}
	// Helper function that computes all local and inherited forward cross references
	def forwardCrossReferences(EClass eClass) {
		eClass.EAllStructuralFeatures.filter[crossReference].filter(EReference)
	}
	// Helper function that computes all local and inherited backward cross references
	def backwardCrossReferences(EClass eClass) {
		eClass.EAllStructuralFeatures.filter[oppositeCrossReference].filter(EReference)
	}

	// Helper function that checks if this is an opposite reference to a containment reference.
	// For a bidirectional containment reference, choose the reference down the containment hierarchy to be forward. 
	def isOppositeContainmentReference(EStructuralFeature eStructuralFeature) {
		switch eStructuralFeature {
			EReference case eStructuralFeature.EOpposite != null && eStructuralFeature.EOpposite.containment: true
			default: false
		}
	}
	// Helper function that checks if this is a containment reference.
	def isContainmentReference(EStructuralFeature eStructuralFeature) {
		switch eStructuralFeature {
			EReference case eStructuralFeature.containment: true
			default: false
		}
	}
	
	// Helper function that checks if this is an opposite reference to a cross reference.
	// For a bidirectional cross reference, choose the reference with the lower bound to be forward.
	// For bidirectional references with equal multiplicities on both sides, choose first in order of appearance in resource to be forward.
	def isOppositeCrossReference(EStructuralFeature eStructuralFeature) {
		val allStructuralFeatures = eStructuralFeature.allStructuralFeatures
		switch eStructuralFeature { 
			EReference case !eStructuralFeature.containment && eStructuralFeature.EOpposite != null && !eStructuralFeature.EOpposite.containment:
				(eStructuralFeature.upperBound == -1 && eStructuralFeature.EOpposite.upperBound > 0) ||
				(eStructuralFeature.upperBound > 0 && eStructuralFeature.EOpposite.upperBound > 0 &&
				 eStructuralFeature.upperBound > eStructuralFeature.EOpposite.upperBound) ||
				(eStructuralFeature.upperBound == eStructuralFeature.EOpposite.upperBound &&
				 allStructuralFeatures.indexOf(eStructuralFeature) > 
				 allStructuralFeatures.indexOf(eStructuralFeature.EOpposite))
			default: false
		}
	}
	// Helper function that checks if this is a cross reference.
	def isCrossReference(EStructuralFeature eStructuralFeature) {
		!eStructuralFeature.oppositeContainmentReference &&
		!eStructuralFeature.containmentReference &&
		!eStructuralFeature.oppositeCrossReference
	}
	
	def mapInheritedClassAttributesToProjections(EClass eClass) '''«
		FOR eSuperType : eClass.EAllSuperTypes»«
			FOR eReference : eSuperType.forwardReferences»
				Definition Project_«eClass.mapClassifier»_«eReference.name.toFirstLower» (o : «eClass.mapClassifier») :=
					 Project_«eReference.EContainingClass.mapClassifier»_«eReference.name.toFirstLower
					 » (Project_«eClass.mapClassifier»_«eReference.EContainingClass.name.toFirstLower» o).«
			ENDFOR»«
		ENDFOR»
	'''

	def mapClassToAllInstancesFunction(EClass eClass, EPackage ePackage) '''
		«IF ePackage.rootClasses.contains(eClass)»
			Definition AllInstances_«eClass.name» («ePackage.name.toLowerCase» : «ePackage.name») : list «eClass.name» :=«
			/* TODO: if multiple classes are root, we must select the requested class from a composed type via inl/inr */»
				(Content «ePackage.name.toLowerCase»).
		«ELSE»
			«val containingReference = eClass.containingReferences.head»
			«val containingClass = containingReference.EContainingClass»
			«val referencedType = containingReference.EReferenceType»
			«val referencedClasses = ePackage.allClasses.concreteClasses.filter(e | e == referencedType || e.inherits(referencedType)).toList»
			«IF containingReference.many && referencedClasses.size > 1 /* list (C + D) */»
			Fixpoint Filter_«eClass.name» (l : «containingReference.mapStructuralFeature») : list «eClass.name» :=
				match l with
				| «val inls = (referencedClasses.size - 1 - referencedClasses.indexOf(eClass))»«
				val inrs = if (referencedClasses.indexOf(eClass) > 0) 1 else 0»«
				(if (inls > 0) (1..inls).map["inl ("].join else "") + (if (inrs > 0) "inr (" else "")»l_head«
				(if (inls + inrs > 0) (1..(inls + inrs)).map[')'].join)» :: l_tail =>
					l_head :: (Filter_«eClass.name» l_tail)
				| _ :: l_tail => (Filter_«eClass.name» l_tail)
				| nil => nil
				end.
			«ELSEIF containingReference.many && referencedClasses.size == 1  /* list C */»
«««			Function Filter_«eClass.name» (l : «containingReference.mapStructuralFeature») : list «eClass.name» :=
«««				l.
			«ELSEIF !containingReference.required && referencedClasses.size > 1 /* option (C + D) */»
			Function Filter_«eClass.name» (o : «containingReference.mapStructuralFeature») : list «eClass.name» :=
				match o with
				| Some «val inls = (referencedClasses.size - 1 - referencedClasses.indexOf(eClass))»«
				val inrs = if (referencedClasses.indexOf(eClass) > 0) 1 else 0»«
				(if (inls > 0) (1..inls).map["inl ("].join else "") + (if (inrs > 0) "inr (" else "")»o'«
				(if (inls + inrs > 0) (1..(inls + inrs)).map[')'].join)» => o'::nil
				| _ => nil
				end.
			«ELSEIF !containingReference.required && referencedClasses.size == 1 /* option C */»
			Function Filter_«eClass.name» (o : «containingReference.mapStructuralFeature») : list «eClass.name» :=
				match o with
				| Some o' => o'::nil
				| None => nil
				end.
			«ELSEIF !containingReference.many && referencedClasses.size > 1 /* (C + D) */»
			Function Filter_«eClass.name» (o : «containingReference.mapStructuralFeature») : list «eClass.name» :=
				match o with
				| «val inls = (referencedClasses.size - 1 - referencedClasses.indexOf(eClass))»«
				val inrs = if (referencedClasses.indexOf(eClass) > 0) 1 else 0»«
				(if (inls > 0) (1..inls).map["inl ("].join else "") + (if (inrs > 0) "inr (" else "")»o'«
				(if (inls + inrs > 0) (1..(inls + inrs)).map[')'].join)» => o'::nil
				| _ => nil
				| nil => nil
				end.
			«ELSEIF !containingReference.many && referencedClasses.size == 1 /* C */»
			Function Filter_«eClass.name» (o : «containingReference.mapStructuralFeature») : list «eClass.name» :=
				o::nil.
			«ENDIF»
			«/* TODO: if multiple classes contain this type, we must merge the instances from each containing reference */»
			Definition AllInstances_«eClass.name» («ePackage.name.toLowerCase» : «ePackage.name») : list «eClass.name» :=
				«IF containingReference.many && referencedClasses.size == 1»					
				(flat_map Project_«containingClass.name»_«containingReference.name»
					(AllInstances_«containingClass.name» «ePackage.name.toLowerCase»)
				).
				«ELSE»					
				(flat_map (fun o =>
						Filter_«eClass.name» (Project_«containingClass.name»_«containingReference.name» o)
					)
					(AllInstances_«containingClass.name» «ePackage.name.toLowerCase»)
				).
				«ENDIF»
		«ENDIF»
	'''

	// Reference is an oid: among all instances of the referenced type, find the instance with that oid 
	def mapClassToDereferenceFunction(EClass eClass, EPackage ePackage) '''
		Function Find_«eClass.name» (l : list «eClass.name») (oid : «eClass.name»_OID) : option «eClass.name» := 
			find (fun oid' => beq_nat 
				(Project_«eClass.name»_OID_nat (Project_«eClass.name»_oid oid')) 
				(Project_«eClass.name»_OID_nat oid) 
				l.
		Function Dereference_«eClass.name» («ePackage.name.toLowerCase» : «ePackage.name») (oid : «eClass.name»_OID) : option «eClass.name» :=
			(Find_«eClass.name» (AllInstances_«eClass.name» «ePackage.name.toLowerCase») oid).
	'''
	
	def mapForwardCrossReferences(EClass eClass, EPackage ePackage) '''
		«FOR eReference : eClass.forwardCrossReferences»
			Definition Dereference_«eClass.name»_«eReference.name» («
				ePackage.name.toLowerCase» : «ePackage.name») (o : «eClass.name») : «
				eReference.mapStructuralFeatureResolvedOIDs» := 
				«IF eReference.many /* list C / list (C + D) => list (option C) / list (option C + option D)*/
					/* Reference is N..M, a list of oids: get that list, and dereference each oid */»
					map (fun oid => (
						«eReference.mapReferenceToTypeSelector(eClass, ePackage)»
					)) (Project_«eClass.name»_«eReference.name» o).
				«ELSEIF !eReference.required /* option C / option (C + D) => option C / (option C + option D) */
					/* Reference is 0..1, an optional oid: dereference oid if it is defined */»
					match (Project_«eClass.name»_«eReference.name» o) with
					| Some oid => (*Some «/* already an option type! */»*) («eReference.mapReferenceToTypeSelector(eClass, ePackage)»)
					| None => None
					end.
				«ELSE /* C => option C */
					/* Reference is 1..1 */»
					let oid := (Project_«eClass.name»_«eReference.name» o) in
					(«eReference.mapReferenceToTypeSelector(eClass, ePackage)»).
				«ENDIF»
«««			«/* TODO: is this really used/useful in a prove? */»
«««			(* Assume any oid used to represent instances of «eReference.EReferenceType.name» 
«««			   referenced from «eClass.name»'s «eReference.name» will be dereferenceable. *)
«««			«/* TODO: adapt for references to composed types */»
«««			Hypothesis «eClass.name»_«eReference.name»_are_Resolvable:
«««				forall «ePackage.name.toLowerCase» : «ePackage.name», 
«««				forall «eReference.EReferenceType.name.toFirstLower» : «eReference.EReferenceType.name»,
«««				In «eReference.EReferenceType.name.toFirstLower» (AllInstances_«eReference.EReferenceType.name» «ePackage.name.toLowerCase») ->
«««				(Dereference_«eClass.name»_«eReference.name» «ePackage.name.toLowerCase» «eReference.EReferenceType.name.toFirstLower») <> (*TODO: inl None*) /\
«««				(Dereference_«eClass.name»_«eReference.name» «ePackage.name.toLowerCase» «eReference.EReferenceType.name.toFirstLower») <> (*TODO: inr None*).
		«ENDFOR»
	'''
	def mapReferenceToTypeSelector(EReference eReference, EClass eClass, EPackage ePackage) '''«
		val referencedClasses = eReference.allClasses.concreteClasses.filter(e | e == eReference.EReferenceType || e.inherits(eReference.EReferenceType)).toList»«
		IF referencedClasses.size > 1»
			match oid with
			«FOR eClass2 : referencedClasses
				»| «
				val inls = (referencedClasses.size - 1 - referencedClasses.indexOf(eClass2))»«
				val inrs = if (referencedClasses.indexOf(eClass2) > 0) 1 else 0»«
				(if (inls > 0) (1..inls).map["inl ("].join else "") + (if (inrs > 0) "inr (" else "")»oid'«
				(1..(inls + inrs)).map[')'].join» => «
				(if (inls > 0) (1..inls).map["inl ("].join else "") + (if (inrs > 0) "inr (" else "")
				»(Dereference_«eClass2.name» «ePackage.name.toLowerCase» oid')«
				(if (inls + inrs > 0) (1..(inls + inrs)).map[')'].join)»
			«ENDFOR»
			end
		«ELSE»
			Dereference_«referencedClasses.head.name» «ePackage.name.toLowerCase» oid«
		ENDIF»'''

	def mapBackwardCrossReferences(EClass eClass, EPackage ePackage) '''
		«FOR eReference : eClass.backwardCrossReferences»
			Definition Dereference_«eClass.name»_«eReference.name» («
				ePackage.name.toLowerCase» : «ePackage.name») (o : «eClass.name») : list «
				eReference.EReferenceType.name/*mapStructuralFeature*/» := «
				/* If an element references multiple objects in backward direction, we use 'filter', not 'find'
				 * TODO: also implement 0..1 multiplicity!
				 * TODO: also consider that backward references may refer to an abstract superclass!!
				 */»
				(filter 
					(fun o' => match (Dereference_«eReference.EReferenceType.name»_«eReference.EOpposite.name» «ePackage.name.toLowerCase» o') with
						| «
						/* TODO: If an element references multiple objects in forward direction, we may get a list */
						val referencedClasses = eReference.EOpposite.allClasses.concreteClasses.filter(e | e == eReference.EOpposite.EReferenceType || e.inherits(eReference.EOpposite.EReferenceType)).toList»«
						val inls = (referencedClasses.size - 1 - referencedClasses.indexOf(eClass))»«
						val inrs = if (referencedClasses.indexOf(eClass) > 0) 1 else 0»«
						(if (inls > 0) (1..inls).map["inl ("].join else "") + (if (inrs > 0) "inr (" else "")»Some o''«
						(if (inls + inrs > 0) (1..(inls + inrs)).map[')'].join)» =>
							beq_nat 
								(Project_«eClass.name»_OID_nat (Project_«eClass.name»_oid o'')) 
								(Project_«eClass.name»_OID_nat (Project_«eClass.name»_oid o))
						| _ => false
						end)
					(AllInstances_«eReference.EReferenceType.name» «ePackage.name.toLowerCase»)
				).
		«ENDFOR»
	'''

	def mapBackwardContainmentReferences(EClass eClass, EPackage ePackage) '''
		«FOR eReference : eClass.backwardContainmentReferences»
			Definition Dereference_«eClass.name»_«eReference.name» («
				ePackage.name.toLowerCase» : «ePackage.name») (o : «eClass.name») : «
				eReference.mapStructuralFeatureResolvedOIDs» := «
				/* Since an element is contained by exactly one object, we can use 'find' */»
				(find 
					(fun o' => 
						let contained := «/* Composed types must be filtered */
						IF eReference.EOpposite.EReferenceType != eClass»(Filter_«eClass.name»«ENDIF»
						(Project_«eReference.EReferenceType.name»_«eReference.EOpposite.name» o')«
						IF eReference.EOpposite.EReferenceType != eClass»)«ENDIF» in
						«IF eReference.EOpposite.many /* <>---> (0..*) */»
						existsb (fun o'' => 
							beq_nat 
								(Project_«eClass.name»_OID_nat (Project_«eClass.name»_oid o'')) 
								(Project_«eClass.name»_OID_nat (Project_«eClass.name»_oid o))
						) contained
						«ELSEIF !eReference.EOpposite.required /* <>---> (0..1) */»
						match contained with
						| Some o'' =>
							beq_nat 
								(Project_«eClass.name»_OID_nat (Project_«eClass.name»_oid o'')) 
								(Project_«eClass.name»_OID_nat (Project_«eClass.name»_oid o))
						| None => false
						end 
						«ENDIF»
					)
					(AllInstances_«eReference.EReferenceType.name» «ePackage.name.toLowerCase»)
				).
		«ENDFOR»
	'''

	def mapClassToHypothesis(EClass eClass, EPackage ePackage) '''
		Axiom «eClass.name»OIDsAreUnique:
			forall «ePackage.name.toLowerCase» : «ePackage.name»,
			forall o1 o2 : «eClass.name»,
				In o1 (AllInstances_«eClass.name» «ePackage.name.toLowerCase») /\
				In o2 (AllInstances_«eClass.name» «ePackage.name.toLowerCase») /\
				((beq_nat (Project_«eClass.name»_OID_nat (Project_«eClass.name»_oid o1))
					(Project_«eClass.name»_OID_nat (Project_«eClass.name»_oid o2))) = true) ->
				o1 = o2.
	'''

	def dispatch mapStructuralFeature(EReference eReference) '''«
		/* For multiplicities N..M with N<M, build a list, and for multiplicities 0..1 build a maybe type */
		IF eReference.many»list «ELSEIF !eReference.required»option «ENDIF
		/* For backward references, use the OID */»«
		val suffix = if (!eReference.containment) "_OID" else ""»«
		/* If class is abstract, built a type of concrete subclasses */
		val concreteSubClasses = eReference.allClasses.concreteClasses.filter(e | e == eReference.EReferenceType || e.inherits(eReference.EReferenceType))»«
		IF concreteSubClasses.size > 1 || concreteSubClasses.head != eReference.EReferenceType»(*«eReference.EReferenceType.name»*) «ENDIF»« 
		FOR eClass : concreteSubClasses
		BEFORE if (concreteSubClasses.size > 1) '(' else ''
		SEPARATOR ' + '
		AFTER if (concreteSubClasses.size > 1) ')' else ''»«
		eClass.mapClassifier»«suffix»«
		ENDFOR
	»'''
	def mapStructuralFeatureResolvedOIDs(EReference eReference) '''«
		/* For multiplicities N..M with N<M, build a list, and for multiplicities 0..1 build a maybe type */
		IF eReference.many»list («ELSE /* it is anyways an option in the end */»«ENDIF
		/* For backward references, use the OID */»«
		IF (eReference.containment)»(* ERROR: no containment references expected! *) «ENDIF»«
		/* If class is abstract, built a type of concrete subclasses */
		val concreteSubClasses = eReference.allClasses.concreteClasses.filter(e | e == eReference.EReferenceType || e.inherits(eReference.EReferenceType))»«
		IF concreteSubClasses.size > 1 || concreteSubClasses.head != eReference.EReferenceType»(*«eReference.EReferenceType.name»*) «ENDIF»« 
		FOR eClass : concreteSubClasses
		BEFORE if (concreteSubClasses.size > 1) '(' else ''
		SEPARATOR ' + '
		AFTER if (concreteSubClasses.size > 1) ')' else ''»option «
		eClass.mapClassifier»«
		ENDFOR»«
		IF eReference.many»)«ENDIF
	»'''
	def dispatch mapStructuralFeature(EAttribute eAttribute) { eAttribute.EAttributeType.mapClassifier }

	def dispatch mapClassifier(EEnum eEnum) '''«eEnum.name»'''
	
	def dispatch mapClassifier(EClass eClass) '''«eClass.name»'''
	
	def dispatch mapClassifier(EDataType eDataType) {
		switch eDataType.name {
			case 'EChar' : 'string'
			case 'EString' : 'string'
			case 'EBoolean' : 'nat'
			case 'EInteger' : 'nat'
			case 'EFloat' : '(* ERROR: Ecore type EFloat is unsupported! *)'
			case 'EByteArray' : '(* ERROR: Ecore type EByteArray is unsupported! *)'
			case 'EFloatObject' : '(* ERROR: Ecore type EFloatObject is unsupported! *)'
			case 'EJavaObject' : '(* ERROR: Ecore type EJavaObject is unsupported! *)'
			default: '(* ERROR: Unsupported type in Coq: ' + eDataType.EPackage.name + '.' + eDataType.name + ' *)'
		}
	}
	
	// Helper function to compute all classes in a given object's resource
	def allClasses(EObject object) {
		object.eResource.allContents.filter(typeof(EClass)).toList
	}
	// Helper function to compute all structural features in a given object's resource
	def allStructuralFeatures(EObject object) {
		object.eResource.allContents.filter(typeof(EClass)).map[EStructuralFeatures].toList
	}
	
	// On any element contained in an ecore model, find the containing package
	def EPackage getPackage(EObject object) {
		if (object instanceof EPackage) (object as EPackage) else object.eContainer.getPackage 
	}
}