(********************************************************************
 Coq definitions for the transformation UML2RDBMS, made up of two parts:
 1. The specification had been automatically generated by QVTrelation2Coq,
 	a code generator that maps QVT-R programs to propositions in Coq.
 2. The implementation had been written manually, together with a proof
 	that ensures compliance with the specification.

 Copyright (c) 2014 Jeffrey Terrell, Steffen Zschaler, Andreas Rentschler
 ********************************************************************)

Add LoadPath "/Users/jeffreyterrell/Dropbox/Research/Writing/Projects/QvtToCoq/Subversion/QVTrv/branches/no-monads/proof".
Add LoadPath "/Users/Andreas/Desktop/UML2RDBMS/proof".

Section UML2RDBMS.

(* Coq libraries *)
Require Import List.
Require Import ListHelpers.
Require Import Arith.
Require Import String.
Require Import Bool.
Require Import Equivalence.
Require Import Omega.

(* use ++ operator instead of append, for example: ("a" ++ "b")%string *)
Delimit Scope string_scope with string.
Local Open Scope string_scope.
Bind Scope string_scope with string.
Open Scope list_scope.
Open Scope equiv_scope.

(* Metamodels *)
(*
import 'UML.ecore';
import 'RDBMS.ecore';
 *)
Require Import UML.
Require Import RDBMS.

(* Define exists_t similar to exists but on Type (program domain, predicative) rather than Prop (logic domain, impredicative).
	"Predicativity is a vulnerability to Russell's paradox that the set S of sets that are not members of themselves can neither be a member of S, nor a non-member of S."
	When extracting a Haskell/Scheme/Ocaml/ML program, Props are removed and thus ignored. Thus we use Type for the root proposition together with exists_t.
 *)
Inductive ex_t (X:Type) (P : X->Type) : Type :=
ex_t_intro : forall (witness:X), P witness -> ex_t X P.
Notation "'exists_t' x : X , p" := (ex_t _ (fun x:X => p))
(at level 200, x ident, right associativity) : type_scope.

(********************************************************************
 Automatically extracted transformation specification
 ********************************************************************)

(*	query PrimitiveTypeToSqlType (typename : String) : String {
		if typename = 'INTEGER' then 'NUMBER' else
			if typename = 'BOOLEAN' then 'BOOLEAN' else 'VARCHAR' endif
		endif
	}
 *)
Function PrimitiveTypeToSqlType (name : string) : RDBMS.TYPE :=
	match name with
	| "Integer" => RDBMS.NUMBER
	| "Boolean" => RDBMS.BOOLEAN
	| _ => RDBMS.VARCHAR
	end
.

(* ---------- AttributeToColumn ---------- *)

(* 	relation AttributeToColumn {
		checkonly domain uml c : UML::Class { };
		enforce domain rdbms t : RDBMS::Table { };
		primitive domain prefix : String;
		where {
			ComplexAttributeToColumn(c, t, prefix);
			PrimitiveAttributeToColumn(c, t, prefix);
			SuperAttributeToColumn(c, t, prefix);
		}
	}
 *)
(* 	relation PrimitiveAttributeToColumn {
		an : String;
		pn : String;
		cn : String;
		sqltype : String;
		checkonly domain uml c : UML::Class {
			attributes = a : UML::Attribute {
				name = an,
				type = p : UML::PrimitiveDataType {
					name = pn
				}
			}
		}; 
		enforce domain rdbms t : RDBMS::Table {
			columns = cl : RDBMS::Column {
				name = cn,
				type = sqltype
			}
		};
		primitive domain prefix : String;
		where {
			cn = if (prefix = '') then an else prefix + '_' + an endif;
			sqltype = PrimitiveTypeToSqlType(pn);
		}
	}
 *)
(* 	relation ComplexAttributeToColumn {
	 		an : String;
	 		newPrefix : String;
	 		checkonly domain uml c : UML::Class {
	 			attributes = a : UML::Attribute {
	 				name = an,
	 				type = tc : UML::Class { }
	 			}
	 		};
	 		enforce domain rdbms t : RDBMS::Table { };
	 		primitive domain prefix : String;
	 		where {
	 			newPrefix = prefix + '_' + an;
	 			AttributeToColumn(tc, t, newPrefix);
	 		}
	 	}
 *)
(* 	relation SuperAttributeToColumn {
	 		checkonly domain uml c : UML::Class {
	 			general = sc : UML::Class { }
	 		};
	 		enforce domain rdbms t : RDBMS::Table { };
	 		primitive domain prefix : String;
	 		where {
	 			AttributeToColumn(sc, t, prefix);
	 		}
	 	}
 *)

(* AttributeToColumn can potentially recurse forever if Class_OID references form a cycle, for example, a class has defined itself as a super type. *)
(* Kind of cheap, but if we make a counter decrease from the number of elements in the input model down to 0 would that help? *)
(* Or can we carry along a list of all available OIDs, and everytime we visit an OID we remove it from the list? *)

Fixpoint AttributeToColumn (c : UML.Class) (t : RDBMS.Table) (prefix : string) : Prop :=

	(* PrimitiveAttributeToColumn *)

	(exists t' : RDBMS.Table, 
	forall an : string,
	forall pn : string,

	forall a : Attribute, 
		In a (UML.Project_Class_attributes c) ->
		UML.Project_Attribute_name a = an ->
		match UML.Project_Attribute_type a with |
			inl _ => True |
			inr p =>
				UML.Project_PrimitiveDataType_name p = pn ->
				exists cn : string,
				exists sqltype : TYPE,
				exists cl : RDBMS.Column,
					In cl (RDBMS.Project_Table_columns t') /\
					RDBMS.Project_Column_name cl = cn /\
					RDBMS.Project_Column_type cl = sqltype /\
					cn = match prefix with "" => an | _ => (prefix ++ "_" ++ an)%string end /\
					sqltype = PrimitiveTypeToSqlType pn
		end)
	/\

	(* ComplexAttributeToColumn *)

	(forall an : string,

		(fix ComplexAttributeToColumn (l : list UML.Attribute) : Prop :=
			match l with |
				nil => True |
				a :: l' =>
					UML.Project_Attribute_name a = an ->
					match UML.Project_Attribute_type a with |
						inl tc =>
							exists newPrefix : string,
								AttributeToColumn tc t newPrefix |
						inr _ => True
					end /\ ComplexAttributeToColumn l'
			end) (UML.Project_Class_attributes c))
	/\

	(* SuperAttributeToColumn *)

	match Project_Class_general c with |
		None => True |
		Some sc => 
			AttributeToColumn sc t prefix
	end
.

(*	top relation PackageToSchema {
		n : String;
		checkonly domain uml p : UML::Package { name = n };
		enforce domain rdbms s : RDBMS::Schema { name = n };
	}
 *)
(* Relation proposition enforces constraints, and can be used to check if a relation holds on a set of variables *)
(* Use the version below, which is generated by pulling the assertions about things belonging to uml/rdbms from the forall implies construction.
Definition PackageToSchema (uml : UML) (rdbms : RDBMS) (PackageToSchema_p : UML.Package) (PackageToSchema_s : RDBMS.Schema) : Prop :=
	forall PackageToSchema_pn : string,
	(*forall PackageToSchema_p : UML.Package,*)
	(
		In PackageToSchema_p (UML.Packages uml) /\
		(UML.Project_Package_name PackageToSchema_p) = PackageToSchema_pn
	) ->
	(*exists PackageToSchema_s : RDBMS.Schema,*)
	(
		In PackageToSchema_s (RDBMS.Schemas rdbms) /\
		(RDBMS.Project_Schema_name PackageToSchema_s) = PackageToSchema_pn
	)
.*)
Definition PackageToSchema (uml : UML) (rdbms : RDBMS) (PackageToSchema_p : UML.Package) (PackageToSchema_s : RDBMS.Schema) : Prop :=
	In PackageToSchema_p (UML.AllInstances_Package uml) /\
	In PackageToSchema_s (RDBMS.AllInstances_Schema rdbms) /\
	forall PackageToSchema_pn : string,
	(*forall PackageToSchema_p : UML.Package,*)
	(
		(UML.Project_Package_name PackageToSchema_p) = PackageToSchema_pn
	) ->
	(*exists PackageToSchema_s : RDBMS.Schema,*)
	(
		(RDBMS.Project_Schema_name PackageToSchema_s) = PackageToSchema_pn
	)
.

(* Top proposition binds variables exhaustively on source and target domain *)
Definition Top_PackageToSchema (uml : UML) (rdbms : RDBMS) : Prop :=
	forall PackageToSchema_pn : string,
	forall PackageToSchema_p : UML.Package,
		In PackageToSchema_p (UML.AllInstances_Package uml) ->
		(UML.Project_Package_name PackageToSchema_p) = PackageToSchema_pn
	->
	exists PackageToSchema_s : RDBMS.Schema,
	(
		In PackageToSchema_s (RDBMS.AllInstances_Schema rdbms) /\
		(RDBMS.Project_Schema_name PackageToSchema_s) = PackageToSchema_pn
	)
.

(*	top relation ClassToTable {
		cn : String;
		prefix : String;
		checkonly domain uml c : UML::Class {
			namespace = p : UML::Package { }, -- backward reference
			kind = UML::KIND::PERSISTENT, --'PERSISTENT'
			name = cn
		};
		enforce domain rdbms t : RDBMS::Table {
			schema = s : RDBMS::Schema { }, -- backward reference
			name = cn,
			columns = cl : RDBMS::Column {
				name = cn + '_tid',
				type = RDBMS::TYPE::NUMBER --'NUMBER'
			},
			keys = k : RDBMS::Key {
				name = cn + '_pk',
				columns = cl : RDBMS::Column { }
			}
		};
		when {
			PackageToSchema(p, s);
		}
		where {
			prefix = "";
			AttributeToColumn(c, t, prefix);
		}
	}
 *)
 
Definition ClassToTable (uml : UML) (rdbms : RDBMS) (ClassToTable_c : UML.Class) (ClassToTable_t : RDBMS.Table) : Prop :=
	In ClassToTable_c (UML.AllInstances_Class uml) /\
	In ClassToTable_t (RDBMS.AllInstances_Table rdbms) /\

	(* When clause *)
	forall ClassToTable_p : UML.Package,
	forall ClassToTable_s : RDBMS.Schema, (* TODO: why not "exists"? *)
	(
		(PackageToSchema uml rdbms ClassToTable_p ClassToTable_s)
	) ->
	(* Source domain *)
	forall ClassToTable_cn : string,
	(*forall ClassToTable_c : UML.Class,
	(
		In ClassToTable_c (UML.Classes uml)
	) ->*)
	(
		(* Source constraints *)
		Some ClassToTable_p = (UML.Dereference_Class_namespace uml ClassToTable_c) /\
		(UML.Project_Class_kind ClassToTable_c) = UML.PERSISTENT /\
		(UML.Project_Class_name ClassToTable_c) = ClassToTable_cn
	) ->

	(* Target domain *)
	(*exists ClassToTable_t : RDBMS.Table,
	(
		In ClassToTable_t (RDBMS.Tables rdbms)
	) /\*)
	exists ClassToTable_cl : RDBMS.Column,
	exists ClassToTable_k : RDBMS.Key,
	(
		(* Target constraints *)
		(RDBMS.Project_Table_name ClassToTable_t) = ClassToTable_cn /\
		Some ClassToTable_s = (RDBMS.Dereference_Table_schema rdbms ClassToTable_t) /\
		In ClassToTable_cl (RDBMS.Project_Table_columns ClassToTable_t) /\
		Some ClassToTable_k = (RDBMS.Project_Table_hasKey ClassToTable_t) /\
		(RDBMS.Project_Column_name ClassToTable_cl) = ((UML.Project_Class_name ClassToTable_c) ++ "_tid")%string /\
		(RDBMS.Project_Column_type ClassToTable_cl) = RDBMS.NUMBER /\
		In (RDBMS.Project_Column_oid ClassToTable_cl) (RDBMS.Project_Key_columns ClassToTable_k) /\
		(RDBMS.Project_Key_name ClassToTable_k) = (ClassToTable_cn ++ "_pk")%string /\
		In (Some ClassToTable_cl) (RDBMS.Dereference_Key_column rdbms ClassToTable_k)
	) /\

	(* Where clause *)
	(
		(AttributeToColumn (*uml*) ClassToTable_c ClassToTable_t "")
	)
.

Definition Top_ClassToTable (uml : UML) (rdbms : RDBMS) : Prop :=
	(* When clause *)
	forall ClassToTable_p : UML.Package,
	exists ClassToTable_s : RDBMS.Schema,
		PackageToSchema uml rdbms ClassToTable_p ClassToTable_s ->

	(* Variables *)
	forall ClassToTable_cn : string,
	forall ClassToTable_prefix : string,

	(* Source domain *)
	forall ClassToTable_c : UML.Class,
		In ClassToTable_c (UML.AllInstances_Class uml) ->

		(* Source constraints *)
		Some ClassToTable_p = (UML.Dereference_Class_namespace uml ClassToTable_c) ->
		(UML.Project_Class_kind ClassToTable_c) = UML.PERSISTENT ->
		(UML.Project_Class_name ClassToTable_c) = ClassToTable_cn ->

	(* Target domain *)
	exists ClassToTable_t : RDBMS.Table,
		In ClassToTable_t (RDBMS.AllInstances_Table rdbms) /\

		(* Target constraints *)
		exists ClassToTable_cl : RDBMS.Column,
		exists ClassToTable_k : RDBMS.Key,
			(RDBMS.Project_Table_name ClassToTable_t) = ClassToTable_cn /\
			Some ClassToTable_s = (RDBMS.Dereference_Table_schema rdbms ClassToTable_t) /\
			In ClassToTable_cl (RDBMS.Project_Table_columns ClassToTable_t) /\
			Some ClassToTable_k = (RDBMS.Project_Table_hasKey ClassToTable_t) /\
			(RDBMS.Project_Column_name ClassToTable_cl) = ((UML.Project_Class_name ClassToTable_c) ++ "_tid")%string /\
			(RDBMS.Project_Column_type ClassToTable_cl) = RDBMS.NUMBER /\
			In (RDBMS.Project_Column_oid ClassToTable_cl) (RDBMS.Project_Key_columns ClassToTable_k) /\
			(RDBMS.Project_Key_name ClassToTable_k) = (ClassToTable_cn ++ "_pk")%string /\
			In (Some ClassToTable_cl) (RDBMS.Dereference_Key_column rdbms ClassToTable_k) /\

	(* Where clause *)
	(ClassToTable_prefix = "" ->
	AttributeToColumn (*uml*) ClassToTable_c ClassToTable_t ClassToTable_prefix)
.

(*	top relation AssocToFKey {
		srcTbl, destTbl : Table;
		pKey : Key;
		an, scn, dcn, fkn, fcn : String;
		checkonly domain uml a : UML::Association {
			namespace = p : UML::Package { }, -- backward reference
			name = an,
			source = sc : UML::Class {
				kind = 'Persistent',
				name = scn
			},
			destination = dc : UML::Class {
				kind = 'Persistent',
				name = dcn
			}
		};
		enforce domain rdbms fk : RDBMS::ForeignKey {
			-- schema = s:Schema {}, -- fix from QVTd's version
			name = fkn,
			owner = srcTbl, -- backward reference
			columns = fc : RDBMS::Column {
				-- owner=srcTbl, -- fix from QVTd's version
				name = fcn,
				type = 'NUMBER'
			},
			refersTo = pKey;
		};
		-- note: when refers to pre-condition
		when {
			PackageToSchema(p, s);
			ClassToTable(sc, srcTbl);
			ClassToTable(dc, destTbl);
			pKey = destTbl.key;
		}
		where {
			fkn = scn + '_' + an + '_' + dcn;
			fcn = fkn + '_tid';
		}
	}
 *)
Definition AssocToFKey (uml : UML) (rdbms : RDBMS) (a : UML.Association) (fk : RDBMS.ForeignKey) : Prop :=
	In a (UML.AllInstances_Association uml) /\
	In fk (RDBMS.AllInstances_ForeignKey rdbms) /\

	(* When clause *)
	forall srcTbl : RDBMS.Table,
	forall destTbl : RDBMS.Table,
	forall pKey : RDBMS.Key,
	forall p : UML.Package,
	forall s : RDBMS.Schema,
	forall sc : UML.Class,
	forall dc : UML.Class,
		(PackageToSchema uml rdbms p s) ->
		(ClassToTable uml rdbms sc srcTbl) ->
		(ClassToTable uml rdbms dc destTbl) ->
		(Some pKey = (RDBMS.Project_Table_hasKey destTbl)) ->
	(* Source domain *)
	(*forall a : UML.Association,*)
	forall an : string,
	forall scn : string,
	forall dcn : string,
	(* Source constraints *)
		Some p = (UML.Dereference_Association_namespace uml a) ->
		(Project_Association_name a) = an ->
		(UML.Dereference_Class uml (Project_Association_source a)) = Some sc ->
		(UML.Project_Class_kind sc) = UML.PERSISTENT ->
		(UML.Project_Class_name sc) = scn ->
		(UML.Dereference_Class uml (Project_Association_destination a)) = Some dc ->
		(UML.Project_Class_kind dc) = UML.PERSISTENT ->
		(UML.Project_Class_name dc) = dcn ->
	(* Target constraints *)
	(*exists fk : RDBMS.ForeignKey,*)
	exists fc : RDBMS.Column,
	exists fkn : string,
	exists fcn : string,
	(
		(Some s = (RDBMS.Dereference_ForeignKey_schema rdbms fk)) /\
		(fkn = (RDBMS.Project_ForeignKey_name fk)) /\
		(Some srcTbl = (RDBMS.Dereference_ForeignKey_owner rdbms fk)) /\
		(In (Some fc) (RDBMS.Dereference_ForeignKey_column rdbms fk)) /\
		(fcn = (RDBMS.Project_Column_name fc)) /\
		(RDBMS.NUMBER = (RDBMS.Project_Column_type fc)) /\
		(Some srcTbl = (RDBMS.Dereference_Column_owner rdbms fc)) /\
		(Some pKey = (RDBMS.Dereference_ForeignKey_refersTo rdbms fk))
	) /\
	(* Where clause *)
	(
		fkn = (scn ++ "_" ++ an ++ "_" ++ dcn)%string /\
		fcn = (fkn ++ "_tid")%string
	)
.
Definition Top_AssocToFKey (uml : UML) (rdbms : RDBMS) : Prop :=
	(* When clause *)
	forall p : UML.Package,
	forall sc : UML.Class,
	forall dc : UML.Class,
	forall pKey : RDBMS.Key, (* no 'exists' because pKey is derived from destTbl *)
	exists srcTbl : RDBMS.Table,
	exists destTbl : RDBMS.Table,
	exists s : RDBMS.Schema,
		(PackageToSchema uml rdbms p s) ->
		(ClassToTable uml rdbms sc srcTbl) ->
		(ClassToTable uml rdbms dc destTbl) ->
		(Some pKey = (RDBMS.Project_Table_hasKey destTbl)) ->
	(* Source domain *)
	forall a : UML.Association,
		In a (UML.AllInstances_Association uml) ->
	forall an : string,
	forall scn : string,
	forall dcn : string,
	(* Source constraints *)
		Some p = (UML.Dereference_Association_namespace uml a) ->
		(Project_Association_name a) = an ->
		(UML.Dereference_Class uml (Project_Association_source a)) = Some sc ->
		(UML.Project_Class_kind sc) = UML.PERSISTENT ->
		(UML.Project_Class_name sc) = scn ->
		(UML.Dereference_Class uml (Project_Association_destination a)) = Some dc ->
		(UML.Project_Class_kind dc) = UML.PERSISTENT ->
		(UML.Project_Class_name dc) = dcn ->
	(* Target constraints *)
	exists fk : RDBMS.ForeignKey,
		In fk (RDBMS.AllInstances_ForeignKey rdbms) /\
	exists fc : RDBMS.Column,
	exists fkn : string,
	exists fcn : string,
	(
		(Some s = (RDBMS.Dereference_ForeignKey_schema rdbms fk)) /\
		(fkn = (RDBMS.Project_ForeignKey_name fk)) /\
		(Some srcTbl = (RDBMS.Dereference_ForeignKey_owner rdbms fk)) /\
		(In (Some fc) (RDBMS.Dereference_ForeignKey_column rdbms fk)) /\
		(fcn = (RDBMS.Project_Column_name fc)) /\
		(RDBMS.NUMBER = (RDBMS.Project_Column_type fc)) /\
		(Some srcTbl = (RDBMS.Dereference_Column_owner rdbms fc)) /\
		(Some pKey = (RDBMS.Dereference_ForeignKey_refersTo rdbms fk))
	) /\
	(* Where clause *)
	(
		fkn = (scn ++ "_" ++ an ++ "_" ++ dcn)%string /\
		fcn = (fkn ++ "_tid")%string
	)
.

(********************************************************************
 Functional program that is supposed to adhere to the given specification
 ********************************************************************)

(* ---------- AttributeToColumn ---------- *)

Function Build_PrimitiveAttributeToColumn (a : UML.Attribute) (p : UML.PrimitiveDataType) (prefix : string) : RDBMS.Column :=
	RDBMS.Build_Column
		(* oid *) (RDBMS.Build_Column_OID (UML.Project_Attribute_OID_nat (UML.Project_Attribute_oid a))) 
		(* super *) (RDBMS.Build_ModelElement
			(* name *) match prefix with
				| "" => (UML.Project_Attribute_name a)
				| _ => (prefix ++ "_" ++ (UML.Project_Attribute_name a))
				end
			(* kind *) EmptyString
		)
		(* type *) (PrimitiveTypeToSqlType (UML.Project_PrimitiveDataType_name p))
		(* keys *) nil
		(* foreignKeys *) nil
.

Fixpoint Establish_AttributeToColumn (c : UML.Class) (prefix : string) : list RDBMS.Column :=

		(* PrimitiveAttributeToColumn *)

		((fix PrimitiveAttributeToColumn (l : list UML.Attribute) : list RDBMS.Column :=
			match l with |
				nil => 
					nil |
				a :: l' =>
					match UML.Project_Attribute_type a with |
						inl _ => 
							PrimitiveAttributeToColumn l'|
						inr pdt =>
							(Build_PrimitiveAttributeToColumn a pdt prefix) :: PrimitiveAttributeToColumn l'
					end
			end) (Project_Class_attributes c)) 
		++

		(* ComplexAttributeToColumn *)

		((fix ComplexAttributeToColumn (l : list UML.Attribute) : list RDBMS.Column :=
			match l with |
				nil => 
					nil |
				a :: l' =>
					match UML.Project_Attribute_type a with |
						inl tc => 
							Establish_AttributeToColumn tc (prefix ++ "_" ++ (UML.Project_Attribute_name a)) ++ 
								ComplexAttributeToColumn l' |
						inr _ =>
							ComplexAttributeToColumn l'
					end
			end) (Project_Class_attributes c)) 
		++

		(* SuperAttributeToColumn *)

		match Project_Class_general c with |
			None => 
				nil |
			Some sc => 
				Establish_AttributeToColumn sc prefix
		end
.

Function Build_AssocToColumn (c1 : UML.Class) (c2 : UML.Class) (a : UML.Association) : RDBMS.Column :=
	RDBMS.Build_Column
		(* oid *) (RDBMS.Build_Column_OID (UML.Project_Association_OID_nat (UML.Project_Association_oid a))) 
		(* super *) (RDBMS.Build_ModelElement
			(* name *) (((UML.Project_Class_name c1) ++ "_" ++ (UML.Project_Association_name a) ++ "_" ++ (UML.Project_Class_name c2)) ++ "_tid")
			(* kind *) EmptyString
		)
		(* type *) RDBMS.NUMBER
		(* keys *) nil
		(* foreignKeys *) nil
.

Function Build_AssocToFKey (c1 : UML.Class) (c2 : UML.Class) (a : UML.Association) : RDBMS.ForeignKey :=
	(RDBMS.Build_ForeignKey
		(* oid *) (RDBMS.Build_ForeignKey_OID (UML.Project_Association_OID_nat (UML.Project_Association_oid a))) 
		(* super *) (RDBMS.Build_ModelElement 
			(* name *) ((UML.Project_Class_name c1) ++ "_" ++ (UML.Project_Association_name a) ++ "_" ++ (UML.Project_Class_name c2))
			(* kind *) EmptyString
		)
		(* This refers to the table that is generated from class c1 *)
		(* owner *) (RDBMS.Build_Table_OID (UML.Project_Class_OID_nat (UML.Project_Class_oid c1)))
		(* This refers to the key representing the table that is generated from class c2 *)
		(* refersTo *) (RDBMS.Build_Key_OID (UML.Project_Class_OID_nat (UML.Project_Class_oid c2)))
		(* This refers to the column generated by Build_AssocToColumn *)
		(* columns *) ((RDBMS.Build_Column_OID (UML.Project_Association_OID_nat (UML.Project_Association_oid a))) :: nil)
	)
.

Function Establish_AssocToFKey (uml : UML) (le : list UML.Association) : list RDBMS.ForeignKey :=
	flat_map (fun assoc: UML.Association => 
		match (UML.Dereference_Class uml (UML.Project_Association_source assoc)), (UML.Dereference_Class uml (UML.Project_Association_destination assoc)) with 
		| Some c1, Some c2 =>  (* ...where source and destination classes are persistent *)
			match (UML.Project_Class_kind c1), (UML.Project_Class_kind c2) with
			| UML.PERSISTENT, UML.PERSISTENT => (Build_AssocToFKey c1 c2 assoc)::nil
 			| _, _ => nil
			end
		| _, _ => nil 
		end)
		le
.

Function Establish_AssocToColumn (uml : UML) (la : list UML.Association) : list RDBMS.Column :=
	flat_map (fun a : UML.Association => 
		match (UML.Dereference_Class uml (UML.Project_Association_source a)) with 
		| Some c1 => 
			match (UML.Dereference_Class uml (UML.Project_Association_destination a)) with 
			| Some c2 => 
				(* ...where source and destination classes are persistent *)
				match (UML.Project_Class_kind c1), (UML.Project_Class_kind c2) with
				| UML.PERSISTENT, UML.PERSISTENT => (Build_AssocToColumn c1 c2 a) :: nil
				| _, _ => nil
				end
			| None => nil 
			end
		| None => nil
		end
	) la
.

Function Build_ClassToTable (uml : UML) (p : UML.Package) (c : UML.Class) (prefix : string) : RDBMS.Table :=
	(RDBMS.Build_Table 
		(* oid *) (RDBMS.Build_Table_OID (UML.Project_Class_OID_nat (UML.Project_Class_oid c))) 
		(* super *) (RDBMS.Build_ModelElement 
			(* name *) (UML.Project_Class_name c) 
			(* kind *) EmptyString
		)
		(* columns *) ((RDBMS.Build_Column
			(* oid *) (RDBMS.Build_Column_OID (UML.Project_Class_OID_nat (UML.Project_Class_oid c))) 
			(* super *) (RDBMS.Build_ModelElement
				(* name *) ((UML.Project_Class_name c) ++ "_tid")
				(* kind *) EmptyString
			)
			(* type *) RDBMS.NUMBER
			(* keys *) nil
			(* foreignKeys *) nil
		) :: ((Establish_AttributeToColumn (*uml*) c prefix) ++ 
			(Establish_AssocToColumn uml (Filter_Association (UML.Project_Package_elements p)))))
		(* hasKey *) (Some (RDBMS.Build_Key
			(* oid *) (RDBMS.Build_Key_OID (UML.Project_Class_OID_nat (UML.Project_Class_oid c))) 
			(* super *) (RDBMS.Build_ModelElement
				(* name *) ((UML.Project_Class_name c) ++ "_pk")
				(* kind *) EmptyString
			)
			(* columns *) ((RDBMS.Build_Column_OID (UML.Project_Class_OID_nat (UML.Project_Class_oid c))) :: nil)
		))
	)
.

Definition Establish_ClassToTable (uml : UML) (p : UML.Package) (lc : list UML.Class) : list RDBMS.Table :=
	flat_map (fun c : UML.Class => 
		match (UML.Project_Class_kind c) with 
		| UML.PERSISTENT => (Build_ClassToTable uml p c EmptyString) :: nil
		| _ => nil
		end
	) lc
.

Function Build_PackageToSchema (uml : UML) (p : UML.Package) : RDBMS.Schema :=
	(RDBMS.Build_Schema 
		(* oid *) (RDBMS.Build_Schema_OID (UML.Project_Package_OID_nat (UML.Project_Package_oid p))) 
		(* super *) (RDBMS.Build_ModelElement 
			(* name *) (UML.Project_Package_name p)
			(* kind *) EmptyString
		)
		(* tables *) (Establish_ClassToTable uml p (UML.Filter_Class (UML.Project_Package_elements p))) 
		(* foreignKeys *) (Establish_AssocToFKey uml (UML.Filter_Association (UML.Project_Package_elements p)))
	)
.

Function Establish_PackageToSchema (uml : UML) : RDBMS :=
	(RDBMS.Build (map (Build_PackageToSchema uml) (UML.AllInstances_Package uml)))
.

(********************************************************************
 Overall transformation specification expressed as a theorem to be proven.
 ********************************************************************)

(* Re-state our hypotheses about only receiving well-formed UML models.
	Note that, as we are being given this as an input model, 
	we can declare this a hypothesis. For RDBMS, which we are generating, 
	we will need to prove this. *)
Hypothesis PackageOIDsAreUnique:
	forall uml : UML,
	forall p1 p2 : Package,
		In p1 (AllInstances_Package uml) /\
		In p2 (AllInstances_Package uml) /\
		((beq_nat (Project_Package_OID_nat (Project_Package_oid p1))
			(Project_Package_OID_nat (Project_Package_oid p2))) = true) ->
		p1 = p2
.

Hypothesis ClassOIDsAreUnique:
	forall uml : UML,
	forall c1 c2 : Class,
		In c1 (AllInstances_Class uml) /\
		In c2 (AllInstances_Class uml) /\
		((beq_nat (Project_Class_OID_nat (Project_Class_oid c1))
			(Project_Class_OID_nat (Project_Class_oid c2))) = true) ->
		c1 = c2
.

Hypothesis AssociationOIDsAreUnique:
	forall uml : UML,
	forall a1 a2 : Association,
		In a1 (AllInstances_Association uml) /\
		In a2 (AllInstances_Association uml) /\
		((beq_nat (Project_Association_OID_nat (Project_Association_oid a1))
			(Project_Association_OID_nat (Project_Association_oid a2))) = true) ->
		a1 = a2
.

(* Needed to proof ColumnOIDsAreUniqueInRDBMS *)
Hypothesis ClassAttributeOIDsAreUnique:
	forall uml : UML,
	forall c : Class,
	forall a : Attribute,
		In c (AllInstances_Class uml) ->
		In a (AllInstances_Attribute uml) ->
		(Project_Class_OID_nat (Project_Class_oid c)) <> 
		(Project_Attribute_OID_nat (Project_Attribute_oid a))
.
Hypothesis ClassAssociationOIDsAreUnique:
	forall uml : UML,
	forall c : Class,
	forall a : Association,
		In c (AllInstances_Class uml) ->
		In a (AllInstances_Association uml) ->
		(Project_Class_OID_nat (Project_Class_oid c)) <>
		(Project_Association_OID_nat (Project_Association_oid a))
.

(* Needed to proof uniqueness constraints in RDBMS *)
Hypothesis PackagesContainClasses:
	forall uml : UML,
	forall p1 p2 : Package,
	forall c : Class,
		In c (Filter_Class (Project_Package_elements p1)) /\
		In c (Filter_Class (Project_Package_elements p2)) ->
		p1 = p2
.

Hypothesis PackagesContainAssociations:
	forall uml : UML,
	forall p1 p2 : Package,
	forall a : Association,
		In a (Filter_Association (Project_Package_elements p1)) /\
		In a (Filter_Association (Project_Package_elements p2)) ->
		p1 = p2
.

Lemma SchemaOIDsAreUnique:
	forall uml : UML,
	forall rdbms : RDBMS,
	forall s1 s2,
		rdbms = Establish_PackageToSchema (uml : UML) /\
		In s1 (AllInstances_Schema rdbms) /\
		In s2 (AllInstances_Schema rdbms) /\
		((beq_nat (Project_Schema_OID_nat (Project_Schema_oid s1))
			(Project_Schema_OID_nat (Project_Schema_oid s2))) = true) ->
		s1 = s2
.
Proof.
	intros.
	destruct H; destruct H0; destruct H1.
	apply beq_nat_true_iff in H2.
	unfold AllInstances_Schema in H0, H1.
	unfold Establish_PackageToSchema in H.
	rewrite H in H0, H1; simpl in H0, H1.
	apply (UnliftPastMaps Package Schema s1 (Build_PackageToSchema uml) (AllInstances_Package uml)) in H0.
	apply (UnliftPastMaps Package Schema s2 (Build_PackageToSchema uml) (AllInstances_Package uml)) in H1.
	destruct H0, H1; destruct H0, H1.

	assert (x = x0).
		apply (PackageOIDsAreUnique uml x x0).
		split.
		assumption.
		split.
		assumption.
		apply beq_nat_true_iff.
		unfold AllInstances_Package in H3.
		unfold Build_PackageToSchema in H0, H1.
		rewrite H0, H1 in H2.
		simpl Project_Schema_OID_nat in H2.
		congruence.

	rewrite H5 in H0.
	rewrite H0, H1.
	reflexivity.
Qed.

Lemma TableOIDsAreUnique:
	forall uml : UML,
	forall rdbms : RDBMS,
	forall t1 t2 : Table,
		rdbms = Establish_PackageToSchema (uml : UML) /\
		In t1 (AllInstances_Table rdbms) /\ In t2 (AllInstances_Table rdbms) ->
		(Project_Table_OID_nat (Project_Table_oid t1)) = (Project_Table_OID_nat (Project_Table_oid t2)) ->
		t1 = t2
.
Proof.
	intros.
	destruct H.
	destruct H1.
	unfold Establish_PackageToSchema in H.
	(* Open up definition of t1. *)
	unfold AllInstances_Table in H1.
	rewrite H in H1.
	unfold AllInstances_Schema in H1.
	simpl (Content {| Content := map (Build_PackageToSchema uml) (AllInstances_Package uml) |}) in H1.
	apply (UnliftPastFlatMaps Schema Table t1 Project_Schema_tables (map (Build_PackageToSchema uml) (AllInstances_Package uml))) in H1.
	destruct H1.
	destruct H1.
	apply (UnliftPastMaps Package Schema x (Build_PackageToSchema uml) (AllInstances_Package uml)) in H3.
	destruct H3.
	destruct H3.
	rewrite H3 in H1.
	unfold Build_PackageToSchema in H1.
	simpl Project_Schema_tables in H1.
	unfold Establish_ClassToTable in H1.
	apply (UnliftPastFlatMaps Class Table t1 
		(fun c : Class =>
			match Project_Class_kind c with
			| PERSISTENT => Build_ClassToTable uml x0 c EmptyString :: nil
			| OTHER => nil
			end)
		(Filter_Class (Project_Package_elements x0))) in H1. 
	destruct H1.
	destruct H1.
	case_eq (Project_Class_kind x1).
		intros.
		rewrite H6 in H1.
		simpl In in H1.
		destruct H1.
			(* Open up definition of t2. *)
			unfold AllInstances_Table in H2.
			rewrite H in H2.
			unfold AllInstances_Schema in H2.
			simpl (Content {| Content := map (Build_PackageToSchema uml) (AllInstances_Package uml) |}) in H2.
			apply (UnliftPastFlatMaps Schema Table t2 Project_Schema_tables (map (Build_PackageToSchema uml) (AllInstances_Package uml))) in H2.
			destruct H2.
			destruct H2.
			apply (UnliftPastMaps Package Schema x2 (Build_PackageToSchema uml) (AllInstances_Package uml)) in H7.
			destruct H7.
			destruct H7.
			rewrite H7 in H2.
			unfold Build_PackageToSchema in H2.
			simpl Project_Schema_tables in H2.
			unfold Establish_ClassToTable in H2.
			apply (UnliftPastFlatMaps Class Table t2 
				(fun c : Class =>
					match Project_Class_kind c with
					| PERSISTENT => Build_ClassToTable uml x3 c EmptyString :: nil
					| OTHER => nil
					end)
				(Filter_Class (Project_Package_elements x3))) in H2.
			destruct H2.
			destruct H2.
			case_eq (Project_Class_kind x4).
				intros.
				rewrite H10 in H2.
				simpl In in H2.
				destruct H2.

					unfold Build_ClassToTable in H1.
					rewrite <- H1 in H0.
					simpl Project_Table_OID_nat in H0.
					unfold Build_ClassToTable in H2.
					rewrite <- H2 in H0.
					simpl Project_Table_OID_nat in H0.
					assert ((Project_Class_OID_nat (Project_Class_oid x1)) = (Project_Class_OID_nat (Project_Class_oid x4))).
						congruence.
					assert (x1 = x4).
						apply (ClassOIDsAreUnique uml x1 x4).
						split.
							unfold AllInstances_Class.
							apply (LiftPastFlatMaps Package Class x0 x1
								(fun p : Package => Filter_Class (Project_Package_elements p))
								(AllInstances_Package uml)).
								assumption.

								assumption.

							split.
								unfold AllInstances_Class.
								apply (LiftPastFlatMaps Package Class x3 x4
									(fun p : Package => Filter_Class (Project_Package_elements p))
									(AllInstances_Package uml)).
									assumption.

									assumption.

								rewrite H11.
								apply (beq_nat_true_iff (Project_Class_OID_nat (Project_Class_oid x4)) (Project_Class_OID_nat (Project_Class_oid x4))).
								reflexivity.

					assert (x0 = x3).
						apply (PackagesContainClasses uml x0 x3 x1).
						split.
						assumption.
						rewrite H12.
						assumption.

					rewrite H12 in H1.
					rewrite H13 in H1.

					rewrite <- H1.
					assumption.

					elim H2.

				intros.
				rewrite H10 in H2.
				elim H2.

			elim H1.

		intros.
		rewrite H6 in H1.
		elim H1.
Qed.

Lemma ForeignKeyOIDsAreUnique:
	forall uml : UML,
	forall rdbms : RDBMS,
	forall fk1 fk2 : ForeignKey,
		rdbms = Establish_PackageToSchema (uml : UML) /\
		In fk1 (AllInstances_ForeignKey rdbms) /\ In fk2 (AllInstances_ForeignKey rdbms) ->
		(Project_ForeignKey_OID_nat (Project_ForeignKey_oid fk1)) = (Project_ForeignKey_OID_nat (Project_ForeignKey_oid fk2)) ->
		fk1 = fk2
.
Proof.
	intros.
	destruct H.
	destruct H1.
	unfold Establish_PackageToSchema in H.
	(* Open up definition of fk1. *)
	unfold AllInstances_ForeignKey in H1.
	rewrite H in H1.
	unfold AllInstances_Schema in H1.
	simpl (Content {| Content := map (Build_PackageToSchema uml) (AllInstances_Package uml) |}) in H1.
	apply (UnliftPastFlatMaps Schema ForeignKey fk1 
		Project_Schema_foreignKeys
		(map (Build_PackageToSchema uml) (AllInstances_Package uml))) in H1.
	destruct H1.
	destruct H1.
	apply (UnliftPastMaps Package Schema x (Build_PackageToSchema uml) (AllInstances_Package uml)) in H3.
	destruct H3.
	destruct H3.
	rewrite H3 in H1.
	unfold Build_PackageToSchema in H1.
	simpl Project_Schema_foreignKeys in H1.
	unfold Establish_AssocToFKey in H1.
	apply (UnliftPastFlatMaps Association ForeignKey fk1
		(fun assoc : Association =>
			match Dereference_Class uml (Project_Association_source assoc) with
			| Some c1 => match Dereference_Class uml (Project_Association_destination assoc) with
				| Some c2 => match Project_Class_kind c1 with
					| PERSISTENT => match Project_Class_kind c2 with
						| PERSISTENT => Build_AssocToFKey c1 c2 assoc :: nil
						| OTHER => nil
						end
					| OTHER => nil
					end
				| None => nil
				end
			| None => nil
			end)
		(Filter_Association (Project_Package_elements x0))) in H1.
	destruct H1.
	destruct H1.
	case_eq (Dereference_Class uml (Project_Association_source x1)).
		intros.
		rewrite H6 in H1.
		case_eq (Dereference_Class uml (Project_Association_destination x1)).
			intros.
			rewrite H7 in H1.
			case_eq (Project_Class_kind c).
				intros.
				rewrite H8 in H1.
				case_eq (Project_Class_kind c0).
					intros.
					rewrite H9 in H1.
					unfold In in H1.
					destruct H1.
						(* Open up definition of fk2. *)
						unfold AllInstances_ForeignKey in H2.
						rewrite H in H2.
						unfold AllInstances_Schema in H2.
						simpl (Content {| Content := map (Build_PackageToSchema uml) (AllInstances_Package uml) |}) in H2.
						apply (UnliftPastFlatMaps Schema ForeignKey fk2 
							Project_Schema_foreignKeys 
							(map (Build_PackageToSchema uml) (AllInstances_Package uml))) in H2.
						destruct H2.
						destruct H2.
						apply (UnliftPastMaps Package Schema x2 (Build_PackageToSchema uml) (AllInstances_Package uml)) in H10.
						destruct H10.
						destruct H10.
						rewrite H10 in H2.
						unfold Build_PackageToSchema in H2.
						simpl Project_Schema_foreignKeys in H2.
						unfold Establish_AssocToFKey in H2.
						apply (UnliftPastFlatMaps Association ForeignKey fk2
							(fun assoc : Association =>
								match Dereference_Class uml (Project_Association_source assoc) with
								| Some c1 => match Dereference_Class uml (Project_Association_destination assoc) with
									| Some c2 => match Project_Class_kind c1 with
										| PERSISTENT => match Project_Class_kind c2 with
											| PERSISTENT => Build_AssocToFKey c1 c2 assoc :: nil
											| OTHER => nil
											end
										| OTHER => nil
										end
									| None => nil
									end
								| None => nil
								end)
							(Filter_Association (Project_Package_elements x3))) in H2.
						destruct H2.
						destruct H2.
						case_eq (Dereference_Class uml (Project_Association_source x4)).
							intros.
							rewrite H13 in H2.
							case_eq (Dereference_Class uml (Project_Association_destination x4)).
								intros.
								rewrite H14 in H2.
								case_eq (Project_Class_kind c1).
									intros.
									rewrite H15 in H2.
									case_eq (Project_Class_kind c2).
										intros.
										rewrite H16 in H2.
										simpl In in H2.
										destruct H2.
											assert (x1 = x4).
												rewrite <- H2 in H0.
												rewrite <- H1 in H0.
												unfold Build_AssocToFKey in H0.
												simpl Project_ForeignKey_OID_nat in H0.
												apply beq_nat_true_iff in H0.
												apply (AssociationOIDsAreUnique uml x1 x4).
												split.
													unfold AllInstances_Association.
													apply (LiftPastFlatMaps Package Association x0 x1
														(fun p : Package => Filter_Association (Project_Package_elements p))
														(AllInstances_Package uml)).
														assumption.

														assumption.

													split.
														unfold AllInstances_Association.
														apply (LiftPastFlatMaps Package Association x3 x4
															(fun p : Package => Filter_Association (Project_Package_elements p))
															(AllInstances_Package uml)).
															assumption.

															assumption.

														assumption.
											assert (c = c1).
												assert (Some c = Some c1).
													rewrite <- H6.
													rewrite <- H13.
													rewrite H17.
													reflexivity.
												congruence.
											assert (c0 = c2).
												assert (Some c0 = Some c2).
													rewrite <- H7.
													rewrite <- H14.
													rewrite H17.
													reflexivity.
												congruence.
											rewrite <- H1.
											rewrite <- H2.
											rewrite H17.
											rewrite H18.
											rewrite H19.
											reflexivity.

											elim H2.

										intros.
										rewrite H16 in H2.
										elim H2.

									intros.
									rewrite H15 in H2.
									elim H2.

								intros.
								rewrite H14 in H2.
								elim H2.

							intros.
							rewrite H13 in H2.
							elim H2.

						elim H1.

					intros.
					rewrite H9 in H1.
					elim H1.

			intros.
			rewrite H8 in H1.
			elim H1.

		intros.
		rewrite H7 in H1.
		elim H1.

	intros. 
	rewrite H6 in H1.
	elim H1.
Qed.

Lemma ColumnOIDsAreUnique:
	forall uml : UML,
	forall rdbms : RDBMS,
	forall c1 c2 : Column,
		rdbms = Establish_PackageToSchema (uml : UML) /\
		In c1 (AllInstances_Column rdbms) /\ In c2 (AllInstances_Column rdbms) ->
		(Project_Column_OID_nat (Project_Column_oid c1)) = (Project_Column_OID_nat (Project_Column_oid c2)) ->
		c1 = c2
.
Proof.
	intros uml rdbms co1 co2 H1 H4.
	destruct H1 as [H1 H2].
	destruct H2 as [H2 H3].
	unfold Establish_PackageToSchema in H1.
	(* Open up definitions of co1 and co2. *)
	unfold AllInstances_Column in H2, H3.
	apply (UnliftPastFlatMaps Table Column co1 Project_Table_columns (AllInstances_Table rdbms)) in H2.
	apply (UnliftPastFlatMaps Table Column co2 Project_Table_columns (AllInstances_Table rdbms)) in H3.
	destruct H2 as [t1 H2].
	destruct H2 as [H2a H2b].
	destruct H3 as [t2 H3].
	destruct H3 as [H3a H3b].
	unfold AllInstances_Table in H2b, H3b.
	apply (UnliftPastFlatMaps Schema Table t1 Project_Schema_tables (AllInstances_Schema rdbms)) in H2b.
	apply (UnliftPastFlatMaps Schema Table t2 Project_Schema_tables (AllInstances_Schema rdbms)) in H3b.
	destruct H2b as [s1 H2b].
	destruct H2b as [H2b H2c].
	destruct H3b as [s2 H3b].
	destruct H3b as [H3b H3c].
	unfold AllInstances_Schema in H2c, H3c.
	rewrite H1 in H2c, H3c.
	simpl Content in H2c, H3c.
	apply (UnliftPastMaps Package Schema s1 (Build_PackageToSchema uml) (AllInstances_Package uml)) in H2c.
	apply (UnliftPastMaps Package Schema s2 (Build_PackageToSchema uml) (AllInstances_Package uml)) in H3c.
	destruct H2c as [p1 H2c].
	destruct H2c as [H2c H2d].
	destruct H3c as [p2 H3c].
	destruct H3c as [H3c H3d].
	rewrite H2c in H2b; rewrite H3c in H3b.
	unfold Build_PackageToSchema in H2b, H3b.
	simpl Project_Schema_tables in H2b, H3b.
	unfold Establish_ClassToTable in H2b, H3b.
	apply (UnliftPastFlatMaps Class Table t1 
		(fun c : Class =>
			match Project_Class_kind c with
			| PERSISTENT => Build_ClassToTable uml p1 c EmptyString :: nil
			| OTHER => nil
			end)
		(Filter_Class (Project_Package_elements p1))) in H2b.
	apply (UnliftPastFlatMaps Class Table t2 
		(fun c : Class =>
			match Project_Class_kind c with
			| PERSISTENT => Build_ClassToTable uml p2 c EmptyString :: nil
			| OTHER => nil
			end)
		(Filter_Class (Project_Package_elements p2))) in H3b.
	destruct H2b as [c1 H2b].
	destruct H2b as [H2b H2e].
	destruct H3b as [c2 H3b].
	destruct H3b as [H3b H3e].
	case_eq (Project_Class_kind c1).
		case_eq (Project_Class_kind c2).
			intros H3f H2f.
			rewrite H2f in H2b; rewrite H3f in H3b.
			simpl in H2b, H3b.
			destruct H2b, H3b.
				rewrite <- H in H2a; rewrite <- H0 in H3a.
				unfold Build_ClassToTable in H2a, H3a.
				simpl Project_Table_columns in H2a, H3a.
				simpl in H2a, H3a.
				destruct H2a, H3a.
					(*assert (Simplify: forall n x y, n + x = n + y -> x = y). intros. omega.
						apply (Simplify 30 (Project_Class_OID_nat (Project_Class_oid c1)) (Project_Class_OID_nat (Project_Class_oid c2))) in H4.*)
					assert (Project_Class_OID_nat (Project_Class_oid c1) = Project_Class_OID_nat (Project_Class_oid c2)).
					{
						rewrite <- H2, <- H3 in H4.
						simpl Project_Column_OID_nat in H4.
						congruence.
					}
					(* Classes are equal *)
					assert (c1 = c2).
					{
						apply (ClassOIDsAreUnique uml c1 c2).
						split.
						unfold AllInstances_Class.
						apply (LiftPastFlatMaps Package Class p1 c1
							(fun p : Package => Filter_Class (Project_Package_elements p)) (AllInstances_Package uml)).

						assumption.

						assumption.

						split.
						unfold AllInstances_Class.
						apply (LiftPastFlatMaps Package Class p2 c2 (fun p : Package => 
								Filter_Class (Project_Package_elements p))
							(AllInstances_Package uml)).
						assumption.

						assumption.

						apply beq_nat_true_iff.
						assumption.
					}
					(* Packages are equal *)
					assert (p1 = p2).
					{
						apply (PackagesContainClasses uml p1 p2 c1).
						split.
						assumption.
						rewrite H6.
						assumption.
					}
					(* Tables t1, t2 are equal (not needed) *)
					rewrite H6 in H2.
					rewrite H2 in H3.

					(* Columns co1, co2 are equal *)
					assumption.

					(* co1 := {|...|} /\ In co2 (Establish_AttributeToColumn c2 "" ++
					Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p2))) *)
					apply (SplitList Column co2 (Establish_AttributeToColumn c2 "") (*++*)
						(Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p2)))) in H3.
					destruct H3.
						(* co1 := {|...|} /\ In co2 (Establish_AttributeToColumn c2 "") *)
						unfold Establish_AttributeToColumn in H3.
						(* This cannot be true, because Class and Attribute's oids are unique *)
(**)				  admit.
						(* co1 := {|...|} /\ In co2 Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p2)) *)
						unfold Establish_AssocToColumn in H3.
						apply (UnliftPastFlatMaps Association Column co2 
							(fun a : Association =>
								match Dereference_Class uml (Project_Association_source a) with
								| Some c1 =>
									match Dereference_Class uml (Project_Association_destination a) with
									| Some c2 =>
										match Project_Class_kind c1 with
										| PERSISTENT =>
											match Project_Class_kind c2 with
											| PERSISTENT => Build_AssocToColumn c1 c2 a :: nil
											| OTHER => nil
											end
										| OTHER => nil
										end
									| None => nil
									end
								| None => nil
								end) 
							(Filter_Association (Project_Package_elements p2))) in H3.
						destruct H3 as [a H3].
						destruct H3 as [H3a H3b].
						case_eq (Dereference_Class uml (Project_Association_source a)).
							intros c3 H3g; rewrite H3g in H3a.
							case_eq (Dereference_Class uml (Project_Association_destination a)).
								intros c4 H3h; rewrite H3h in H3a.
								case_eq (Project_Class_kind c3).
									intros H3i; rewrite H3i in H3a.
									case_eq (Project_Class_kind c4).
										intros H3j; rewrite H3j in H3a.
										simpl In in H3a; destruct H3a.
											rewrite <- H2, <- H3.

											(* This cannot be true, because Class and Association's oids are unique *)
											apply ColumnsAreEqual.
											split. simpl Project_Column_OID_nat.
											contradiction (ClassAssociationOIDsAreUnique uml c1 a). admit.
											apply (LiftPastFlatMaps Package Class p1 c1 (fun p0 : Package =>
													Filter_Class (Project_Package_elements p0))
												(AllInstances_Package uml)) in H2e.
											apply (LiftPastFlatMaps Package Association p2 a (fun p0 : Package =>
													Filter_Association (Project_Package_elements p0))
												(AllInstances_Package uml)) in H3b.
											generalize H2e, H3b.

											(*contradict (ClassAssociationOIDsAreUnique uml c1 a).*)

(**)									  admit. admit. admit. admit. admit.
										elim H3.
									intro H3j; rewrite H3j in H3a; elim H3a.
								intro H3i; rewrite H3i in H3a; elim H3a.
							intro H3h; rewrite H3h in H3a; elim H3a.
						intro H3g; rewrite H3g in H3a; elim H3a.

				(* co2 := {|...|} /\ In co1 (Establish_AttributeToColumn c1 "" ++
					Establish_A	ssocToColumn uml (Filter_Association (Project_Package_elements p1))) *)
				(* Same procedure as above *)
(**)		  admit.

				(* In co1 (Establish_AttributeToColumn c1 "" ++ Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p1))) /\
					In co2 (Establish_AttributeToColumn c2 "" ++ Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p2))) *)
				apply (SplitList Column co1 (Establish_AttributeToColumn c1 "") (*++*)
					(Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p1)))) in H2.
				destruct H2.
					apply (SplitList Column co2 (Establish_AttributeToColumn c2 "") (*++*)
						(Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p2)))) in H3.
					destruct H3.
						(* In co1 (Establish_AttributeToColumn c1 "") /\ 
							In co2 (Establish_AttributeToColumn c2 "") *)
(**)				  admit.
						(* In co1 (Establish_AttributeToColumn c1 "") /\ 
							In co2 (Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p2))) *)
(**)				  admit.
					apply (SplitList Column co2 (Establish_AttributeToColumn c2 "") (*++*)
						(Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p2)))) in H3.
					destruct H3.
						(* In co2 (Establish_AttributeToColumn c1 "") /\ 
							In co1 (Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p2))) *)
(**)				  admit.
						(* In co2 (Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p1))) /\ 
							In co1 (Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p2))) *)
						unfold Establish_AssocToColumn in H2, H3.
						apply (UnliftPastFlatMaps Association Column co1 
							(fun a : Association =>
								match Dereference_Class uml (Project_Association_source a) with
								| Some c1 =>
									match Dereference_Class uml (Project_Association_destination a) with
										| Some c2 =>
											match Project_Class_kind c1 with
											| PERSISTENT =>
												match Project_Class_kind c2 with
												| PERSISTENT => Build_AssocToColumn c1 c2 a :: nil
												| OTHER => nil
												end
											| OTHER => nil
											end
										| None => nil
									end
								| None => nil
								end) 
									 (Filter_Association (Project_Package_elements p1))) in H2.
						apply (UnliftPastFlatMaps Association Column co2 
							(fun a : Association =>
								match Dereference_Class uml (Project_Association_source a) with
								| Some c1 =>
									match Dereference_Class uml (Project_Association_destination a) with
									| Some c2 =>
										match Project_Class_kind c1 with
										| PERSISTENT =>
											match Project_Class_kind c2 with
											| PERSISTENT => Build_AssocToColumn c1 c2 a :: nil
											| OTHER => nil
											end
										| OTHER => nil
										end
									| None => nil
									end
								| None => nil
								end) 
							(Filter_Association (Project_Package_elements p2))) in H3.
						destruct H2 as [a1 H2].
						destruct H2 as [H2a H2b].
						destruct H3 as [a2 H3].
						destruct H3 as [H3a H3b].
						case_eq (Dereference_Class uml (Project_Association_source a1)).
						case_eq (Dereference_Class uml (Project_Association_source a2)).
							intros c5 H3g c3 H2g; rewrite H3g in H3a; rewrite H2g in H2a.
							case_eq (Dereference_Class uml (Project_Association_destination a1)).
							case_eq (Dereference_Class uml (Project_Association_destination a2)).
								intros c6 H3h c4 H2h; rewrite H3h in H3a; rewrite H2h in H2a.
								case_eq (Project_Class_kind c3).
								case_eq (Project_Class_kind c5).
									intros H3i H2i; rewrite H3i in H3a; rewrite H2i in H2a.
									case_eq (Project_Class_kind c4).
									case_eq (Project_Class_kind c6).
										intros H3j H2j; rewrite H3j in H3a; rewrite H2j in H2a.
										simpl In in H2a; destruct H2a.
										simpl In in H3a; destruct H3a.
											rewrite <- H2, <- H3.
											unfold Build_AssocToColumn.
											(* This is true exactly if a1 = a2 /\ c3 = c5 /\ c4 = c6 *)
											assert (a1 = a2).
												apply (AssociationOIDsAreUnique uml a1 a2); repeat split.
													unfold AllInstances_Association.
													apply (LiftPastFlatMaps Package Association p1 a1 (fun p0 : Package =>
															Filter_Association (Project_Package_elements p0))
														(AllInstances_Package uml)).
													assumption.
													assumption.

													unfold AllInstances_Association.
													apply (LiftPastFlatMaps Package Association p2 a2 (fun p0 : Package =>
															Filter_Association (Project_Package_elements p0))
														(AllInstances_Package uml)).
													assumption.
													assumption.

													apply beq_nat_true_iff.

													(*rewrite <- H7 in H6.
													assert (forall x y, x = y -> Project_ForeignKey_OID_nat (Project_ForeignKey_oid x) = Project_ForeignKey_OID_nat (Project_ForeignKey_oid y)).
														intros. rewrite H8. reflexivity.
													apply (H8 (Build_AssocToFKey c c0 a3) (Build_AssocToFKey c1 c2 a4)).
													assumption.

													assert (p1 = p2).
													rewrite H8 in HA3b.
													apply (PackagesContainAssociations uml p1 p2 a4).
													split. assumption. assumption.

													rewrite H9; reflexivity.*)

(**)									admit. admit.
										elim H3.
										elim H2.
									intro H3j; rewrite H3j in H3a; elim H3a.
									intro H2j; rewrite H2j in H2a; elim H2a.
								intro H3i; rewrite H3i in H3a; elim H3a.
								intro H2i; rewrite H2i in H2a; elim H2a.
							intro H3h; rewrite H3h in H3a; elim H3a.
							intro H2h; rewrite H2h in H2a; elim H2a.
						intro H3g; rewrite H3g in H3a; elim H3a.
						intro H2g; rewrite H2g in H2a; elim H2a.
			elim H0.
			elim H.
			elim H0.
		intro H; rewrite H in H3b; elim H3b.
	intro H; rewrite H in H2b; elim H2b.
Qed.

Lemma KeyOIDsAreUnique:
	forall uml : UML,
	forall rdbms : RDBMS,
	forall k1 k2 : Key,
		rdbms = Establish_PackageToSchema (uml : UML) /\
		In k1 (AllInstances_Key rdbms) /\ In k2 (AllInstances_Key rdbms) ->
		(Project_Key_OID_nat (Project_Key_oid k1)) = (Project_Key_OID_nat (Project_Key_oid k2)) ->
		k1 = k2
.
Proof.
	intros uml rdbms k1 k2 H1 H4.
	destruct H1 as [H1 H2].
	destruct H2 as [H2 H3].
	unfold Establish_PackageToSchema in H1.
	(* Open up definition of k1. *)
	unfold AllInstances_Key in H2, H3.
	apply (UnliftPastFlatMaps Table Key k1 (fun o : Table => Filter_Key (Project_Table_hasKey o)) (AllInstances_Table rdbms)) in H2.
	apply (UnliftPastFlatMaps Table Key k2 (fun o : Table => Filter_Key (Project_Table_hasKey o)) (AllInstances_Table rdbms)) in H3.
	destruct H2 as [t1 H2].
	destruct H2 as [H2a H2b].
	destruct H3 as [t2 H3].
	destruct H3 as [H3a H3b].
	unfold AllInstances_Table in H2b, H3b.
	apply (UnliftPastFlatMaps Schema Table t1 Project_Schema_tables (AllInstances_Schema rdbms)) in H2b.
	apply (UnliftPastFlatMaps Schema Table t2 Project_Schema_tables (AllInstances_Schema rdbms)) in H3b.
	destruct H2b as [s1 H2b].
	destruct H2b as [H2b H2c].
	destruct H3b as [s2 H3b].
	destruct H3b as [H3b H3c].
	unfold AllInstances_Schema in H2c, H3c.
	rewrite H1 in H2c, H3c.
	simpl Content in H2c, H3c.
	apply (UnliftPastMaps Package Schema s1 (Build_PackageToSchema uml) (AllInstances_Package uml)) in H2c.
	apply (UnliftPastMaps Package Schema s2 (Build_PackageToSchema uml) (AllInstances_Package uml)) in H3c.
	destruct H2c as [p1 H2c].
	destruct H2c as [H2c H2d].
	destruct H3c as [p2 H3c].
	destruct H3c as [H3c H3d].
	rewrite H2c in H2b; rewrite H3c in H3b.
	unfold Build_PackageToSchema in H2b, H3b.
	simpl Project_Schema_tables in H2b, H3b.
	unfold Establish_ClassToTable in H2b, H3b.
	apply (UnliftPastFlatMaps Class Table t1 
		(fun c : Class =>
			match Project_Class_kind c with
			| PERSISTENT => Build_ClassToTable uml p1 c EmptyString :: nil
			| OTHER => nil
			end)
		(Filter_Class (Project_Package_elements p1))) in H2b.
	apply (UnliftPastFlatMaps Class Table t2 
		(fun c : Class =>
			match Project_Class_kind c with
			| PERSISTENT => Build_ClassToTable uml p2 c EmptyString :: nil
			| OTHER => nil
			end)
		(Filter_Class (Project_Package_elements p2))) in H3b.
	destruct H2b as [c1 H2b].
	destruct H2b as [H2b H2e].
	destruct H3b as [c2 H3b].
	destruct H3b as [H3b H3e].
	case_eq (Project_Class_kind c1).
		case_eq (Project_Class_kind c2).
			intros H3f H2f.
			rewrite H2f in H2b; rewrite H3f in H3b.
			simpl in H2b, H3b.
			destruct H2b, H3b.
				rewrite <- H in H2a; rewrite <- H0 in H3a.
				unfold Filter_Key in H2a, H3a.
				unfold Build_ClassToTable in H2a, H3a.
				simpl Project_Table_hasKey in H2a, H3a.
				simpl in H2a, H3a.
				destruct H2a, H3a.
					(*assert (Simplify: forall n x y, n + x = n + y -> x = y). intros. omega.
						apply (Simplify 30 (Project_Class_OID_nat (Project_Class_oid c1)) (Project_Class_OID_nat (Project_Class_oid c2))) in H4.*)
					assert (Project_Class_OID_nat (Project_Class_oid c1) = Project_Class_OID_nat (Project_Class_oid c2)).
					{
						rewrite <- H2, <- H3 in H4.
						simpl Project_Key_OID_nat in H4.
						congruence.
					}
					(* Classes are equal *)
					assert (c1 = c2).
					{
						apply (ClassOIDsAreUnique uml c1 c2).
						split.
						unfold AllInstances_Class.
						apply (LiftPastFlatMaps Package Class p1 c1
							(fun p : Package => Filter_Class (Project_Package_elements p)) (AllInstances_Package uml)).

						assumption.

						assumption.

						split.
						unfold AllInstances_Class.
						apply (LiftPastFlatMaps Package Class p2 c2 (fun p : Package => 
								Filter_Class (Project_Package_elements p))
							(AllInstances_Package uml)).
						assumption.

						assumption.

						apply beq_nat_true_iff.
						assumption.
					}
					(* Packages are equal *)
					assert (p1 = p2).
					{
						apply (PackagesContainClasses uml p1 p2 c1).
						split.
						assumption.
						rewrite H6.
						assumption.
					}
					(* Tables t1, t2 are equal (not needed) *)
					rewrite H6 in H2.
					rewrite H2 in H3.

					(* Keys k1, k2 are equal *)
					rewrite H6, H7 in H.
					rewrite H0 in H.
					assumption.
				elim H3.
				elim H2.
				elim H3.
			elim H0.
			elim H.
			elim H0.
		intro H; rewrite H in H3b; elim H3b.
	intro H; rewrite H in H2b; elim H2b.
Qed.

Lemma SchemasContainTables: 
	forall uml : UML,
	forall rdbms : RDBMS, 
	forall s1 s2 : Schema, 
	forall t : Table,
		rdbms = Establish_PackageToSchema (uml : UML) /\
		In s1 (AllInstances_Schema rdbms) /\ In s2 (AllInstances_Schema rdbms) /\
		In t (Project_Schema_tables s1) /\ In t (Project_Schema_tables s2) ->
		s1 = s2
.
Proof.
	intros.
	destruct H.
	destruct H0.
	destruct H1.
	destruct H2.
	unfold Establish_PackageToSchema in H.
	(* Open up s1. *)
	rewrite H in H0.
	unfold AllInstances_Schema in H0.
	simpl Content in H0.
	apply (UnliftPastMaps Package Schema s1 (Build_PackageToSchema uml) (AllInstances_Package uml)) in H0.
	destruct H0.
	destruct H0.
	rewrite H0 in H2.
	unfold Build_PackageToSchema in H2.
	simpl Project_Schema_tables in H2.
	unfold Establish_ClassToTable in H2.
	apply (UnliftPastFlatMaps Class Table t 
		(fun c : Class =>
			match Project_Class_kind c with
			| PERSISTENT => Build_ClassToTable uml x c EmptyString :: nil
			| OTHER => nil
			end)
		(Filter_Class (Project_Package_elements x))) in H2.
	destruct H2.
	destruct H2.
	case_eq (Project_Class_kind x0).
		intros.
		rewrite H6 in H2.
		simpl In in H2.
		destruct H2.
			(* Open up s2. *)
			rewrite H in H1.
			unfold AllInstances_Schema in H1.
			simpl Content in H1.
			apply (UnliftPastMaps Package Schema s2 (Build_PackageToSchema uml) (AllInstances_Package uml)) in H1.
			destruct H1.
			destruct H1.
			rewrite H1 in H3.
			unfold Build_PackageToSchema in H3.
			simpl Project_Schema_tables in H3.
			unfold Establish_ClassToTable in H3.
			apply (UnliftPastFlatMaps Class Table t 
				(fun c : Class =>
					match Project_Class_kind c with
					| PERSISTENT => Build_ClassToTable uml x1 c EmptyString :: nil
					| OTHER => nil
					end)
				(Filter_Class (Project_Package_elements x1))) in H3.
			destruct H3.
			destruct H3.
			case_eq (Project_Class_kind x2).
				intros.
				rewrite H9 in H3.
				simpl In in H3.
				destruct H3.
					assert (x0 = x2).
						assert ((Project_Class_OID_nat (Project_Class_oid x0)) = (Project_Class_OID_nat (Project_Class_oid x2))).
							assert ((Project_Table_oid (Build_ClassToTable uml x x0 EmptyString)) = (Project_Table_oid (Build_ClassToTable uml x1 x2 EmptyString))).
								rewrite H3.
								rewrite H2.
								reflexivity.
							unfold Build_ClassToTable in H10.
							simpl Project_Table_oid in H10.
							congruence.
						apply (ClassOIDsAreUnique uml x0 x2).
						split.
							unfold AllInstances_Class.
							apply (LiftPastFlatMaps Package Class x x0
								(fun p : Package => Filter_Class (Project_Package_elements p))
								(AllInstances_Package uml)).
								assumption.

								assumption.

							split.
								unfold AllInstances_Class.
								apply (LiftPastFlatMaps Package Class x1 x2
									(fun p : Package => Filter_Class (Project_Package_elements p))
									(AllInstances_Package uml)).
									assumption.

									assumption.

								apply (beq_nat_true_iff (Project_Class_OID_nat (Project_Class_oid x0)) (Project_Class_OID_nat (Project_Class_oid x2))).
								assumption.
					assert (x1 = x).
						apply (PackagesContainClasses uml x1 x x0).
						split.
							rewrite H10.
							assumption.

							assumption.
					rewrite H11 in H1.
					rewrite <- H1 in H0.
					assumption.

					elim H3.

				intros.
				rewrite H9 in H3.
				elim H3.
			
			elim H2.

		intros.
		rewrite H6 in H2.
		elim H2.
Qed.

Lemma SchemasContainForeignKeysInRDBMS: 
	forall uml : UML,
	forall rdbms : RDBMS,
		rdbms = Establish_PackageToSchema (uml : UML) ->
	forall s1 s2 : Schema, 
	forall fk : ForeignKey,
		In s1 (AllInstances_Schema rdbms) /\ In s2 (AllInstances_Schema rdbms) /\
		In fk (Project_Schema_foreignKeys s1) /\
		In fk (Project_Schema_foreignKeys s2) ->
		s1 = s2.
Proof.
{
	intros uml rdbms.
	intro H1eq.
	intros s1 s2 fk0.
	rewrite H1eq.
	intro HA.
	destruct HA as [HA1 HA2]; destruct HA2 as [HA2 HA3]; destruct HA3 as [HA3 HA4].
	apply (SchemaOIDsAreUnique uml rdbms).
	split.
	exact H1eq.
	rewrite H1eq.
	split.
	exact HA1.
	split.
	exact HA2.
	apply beq_nat_true_iff.

	(* follow schema s1/s2 to their originating package p1/p2 *)
	unfold AllInstances_Schema in HA1, HA2.
	unfold Establish_PackageToSchema in HA1, HA2.
	simpl Content in HA1, HA2.
	apply (UnliftPastMaps Package Schema s1 (Build_PackageToSchema uml) (AllInstances_Package uml)) in HA1.
	apply (UnliftPastMaps Package Schema s2 (Build_PackageToSchema uml) (AllInstances_Package uml)) in HA2.
	destruct HA1 as [p1 HA1].
	destruct HA2 as [p2 HA2].
	destruct HA1 as [HA1a HA1b].
	destruct HA2 as [HA2a HA2b].
	rewrite HA1a, HA2a.
	unfold Build_PackageToSchema.
	simpl Project_Schema_OID_nat.

	(* follow foreign keys fk0 from package p1/p2 to their originating association a3/a4 *)
	rewrite HA1a in HA3; rewrite HA2a in HA4.
	unfold Build_PackageToSchema in HA3, HA4.
	simpl Project_Schema_foreignKeys in HA3, HA4.
	unfold Establish_AssocToFKey in HA3, HA4.
	(* HA3: In fk0 (Project_Schema_foreignKeys (Build_PackageToSchema uml p1)) *)
	apply (UnliftPastFlatMaps Association ForeignKey fk0
		(fun assoc : Association =>
			match Dereference_Class uml (Project_Association_source assoc) with
			| Some c1 => match Dereference_Class uml (Project_Association_destination assoc) with
				| Some c2 => match Project_Class_kind c1 with
					| PERSISTENT => match Project_Class_kind c2 with
						| PERSISTENT => Build_AssocToFKey c1 c2 assoc :: nil
						| OTHER => nil
						end
					| OTHER => nil
					end
				| None => nil
				end
			| None => nil
			end)
		  (Filter_Association (Project_Package_elements p1))) in HA3.
	destruct HA3 as [a3 HA3].
	destruct HA3 as [HA3a HA3b].
	case_eq (Dereference_Class uml (Project_Association_source a3)).
		intros.
		rewrite H in HA3a.
		case_eq (Dereference_Class uml (Project_Association_destination a3)).
			intros.
			rewrite H0 in HA3a.
			case_eq (Project_Class_kind c).
				intros.
				rewrite H1 in HA3a.
				case_eq (Project_Class_kind c0).
					intros.
					rewrite H2 in HA3a.
					destruct H1.
					(* HA4: In fk0 (Project_Schema_foreignKeys (Build_PackageToSchema uml p2)) *)
					apply (UnliftPastFlatMaps Association ForeignKey fk0
						(fun assoc : Association =>
							match Dereference_Class uml (Project_Association_source assoc) with
							| Some c1 => match Dereference_Class uml (Project_Association_destination assoc) with
								| Some c2 => match Project_Class_kind c1 with
									| PERSISTENT => match Project_Class_kind c2 with
										| PERSISTENT => Build_AssocToFKey c1 c2 assoc :: nil
										| OTHER => nil
										end
									| OTHER => nil
									end
								| None => nil
								end
							| None => nil
							end)
						(Filter_Association (Project_Package_elements p2))) in HA4.
					destruct HA4 as [a4 HA4].
					destruct HA4 as [HA4a HA4b].
					case_eq (Dereference_Class uml (Project_Association_source a4)).
						intros.
						rewrite H1 in HA4a.
						case_eq (Dereference_Class uml (Project_Association_destination a4)).
							intros.
							rewrite H3 in HA4a.
							case_eq (Project_Class_kind c1).
								intros.
								rewrite H4 in HA4a.
								case_eq (Project_Class_kind c2).
									intros.
									rewrite H5 in HA4a.
									unfold In in HA4a.
									destruct HA3a.
										destruct HA4a.
											assert (a3 = a4).
											apply (AssociationOIDsAreUnique uml a3 a4); repeat split.
		  
											unfold AllInstances_Association.
											apply (LiftPastFlatMaps Package Association p1 a3 (fun p0 : Package =>
													Filter_Association (Project_Package_elements p0))
												(AllInstances_Package uml)).
											assumption.
											assumption.

											unfold AllInstances_Association.
											apply (LiftPastFlatMaps Package Association p2 a4 (fun p0 : Package =>
													 Filter_Association (Project_Package_elements p0))
												(AllInstances_Package uml)).
											assumption.
											assumption.

											apply beq_nat_true_iff.

											rewrite <- H7 in H6.
											assert (forall x y, x = y -> Project_ForeignKey_OID_nat (Project_ForeignKey_oid x) = Project_ForeignKey_OID_nat (Project_ForeignKey_oid y)).
												intros. rewrite H8. reflexivity.
											apply (H8 (Build_AssocToFKey c c0 a3) (Build_AssocToFKey c1 c2 a4)).
											assumption.

											assert (p1 = p2).
											rewrite H8 in HA3b.
											apply (PackagesContainAssociations uml p1 p2 a4).
											split. assumption. assumption.

											rewrite H9; reflexivity.

										elim H7.
									elim H6.
								intros.
								rewrite H5 in HA4a.
								elim HA4a.
							intros.
							rewrite H4 in HA4a.
							elim HA4a.
						intros.
						rewrite H3 in HA4a.
						elim HA4a.
					intros.
					rewrite H1 in HA4a.
					elim HA4a.
				intros.
				rewrite H2 in HA3a.
				elim HA3a.
			intros.
			rewrite H1 in HA3a.
			elim HA3a.
		intros.
		rewrite H0 in HA3a.
		elim HA3a.
	intros.
	rewrite H in HA3a.
	elim HA3a.
}
Qed.

Lemma ForeignKeyInSchema :
	forall uml : UML,
	forall rdbms : RDBMS,
		rdbms = Establish_PackageToSchema (uml : UML) ->
	forall p : Package,
	forall s : Schema,
		s = Build_PackageToSchema uml p ->
		PackageToSchema uml (Establish_PackageToSchema uml) p s ->
	forall a : Association,
		In a (AllInstances_Association uml) ->
		Some p = Dereference_Association_namespace uml a ->
	forall sc dc : Class,
		Dereference_Class uml (Project_Association_source a) = Some sc ->
		Project_Class_kind sc = PERSISTENT ->
		Dereference_Class uml (Project_Association_destination a) = Some dc ->
		Project_Class_kind dc = PERSISTENT ->
	forall fk : ForeignKey,
		fk = Build_AssocToFKey sc dc a ->
		In fk (Project_Schema_foreignKeys s).
Proof.
	intros uml rdbms H1eq p s Hs H2 a H6 H6eq sc dc H8eq H9eq H11eq H12eq fk Hfk.

	rewrite Hs.
	unfold Build_PackageToSchema.
	simpl Project_Schema_foreignKeys.
	unfold Establish_AssocToFKey.

	apply (LiftPastFlatMaps 
		Association 
		ForeignKey
		a fk
		(fun assoc : Association =>
			match Dereference_Class uml (Project_Association_source assoc) with
			| Some c1 =>
				match
					Dereference_Class uml (Project_Association_destination assoc)
				with
				| Some c2 =>
					match Project_Class_kind c1 with
					| PERSISTENT =>
						match Project_Class_kind c2 with
						| PERSISTENT => Build_AssocToFKey c1 c2 assoc :: nil
						| OTHER => nil
						end
					| OTHER => nil
					end
				| None => nil
				end
			| None => nil
			end) (Filter_Association (Project_Package_elements p))).
	case_eq (Dereference_Class uml (Project_Association_source a)).
		intros. rewrite H in H8eq.
		case_eq (Dereference_Class uml (Project_Association_destination a)).
			intros. rewrite H0 in H11eq.
			case_eq (Project_Class_kind c).
				intros.
				case_eq (Project_Class_kind c0).
					intros.
					simpl.
					left.
					rewrite Hfk.
					congruence.
				congruence.
			congruence.
		congruence.
	congruence.
	assert (p = p). reflexivity.
	apply (Consistent_Dereference_Association_namespace AssociationOIDsAreUnique uml p a).

	unfold PackageToSchema in H2.
	destruct H2 as [H2a H2b].
	assumption.

	(* In a (AllInstances_Association uml) *)
	assumption.

	(* Some p = Dereference_Association_namespace uml a *)
	assumption.
Qed.

Lemma SchemaInRDBMS :
	forall uml : UML,
	forall rdbms : RDBMS,
		rdbms = Establish_PackageToSchema (uml : UML) ->
	forall p : Package,
	forall s : Schema,
		s = Build_PackageToSchema uml p ->
		PackageToSchema uml (Establish_PackageToSchema uml) p s ->
		In s (AllInstances_Schema rdbms).
Proof.
   intros uml rdbms H1eq p s Hs H2.
   rewrite H1eq.
   unfold AllInstances_Schema.
   unfold Establish_PackageToSchema.
   simpl Content.

   apply (LiftPastMaps Package Schema p s (Build_PackageToSchema uml) (AllInstances_Package uml)).
   trivial.

   unfold PackageToSchema in H2.
   destruct H2 as [H2a H2b].
   assumption.
Qed.

Lemma ForeignKeyInRDBMS :
	forall uml : UML,
	forall rdbms : RDBMS,
		rdbms = Establish_PackageToSchema (uml : UML) ->
	forall p : Package,
	forall s : Schema,
		s = Build_PackageToSchema uml p ->
		PackageToSchema uml (Establish_PackageToSchema uml) p s ->
	forall a : Association,
		In a (AllInstances_Association uml) ->
		Some p = Dereference_Association_namespace uml a ->
	forall sc dc : Class,
		Dereference_Class uml (Project_Association_source a) = Some sc ->
		Project_Class_kind sc = PERSISTENT ->
		Dereference_Class uml (Project_Association_destination a) = Some dc ->
		Project_Class_kind dc = PERSISTENT ->
	forall fk : ForeignKey,
		fk = Build_AssocToFKey sc dc a ->
		In fk (AllInstances_ForeignKey rdbms).
{
	intros uml rdbms H1eq p s Hs H2 a H6 H6eq sc dc H8eq H9eq H11eq H12eq fk Hfk.

	rewrite H1eq.
	unfold AllInstances_ForeignKey.
	apply (LiftPastFlatMaps 
		Schema 
		ForeignKey 
		s 
		fk 
		Project_Schema_foreignKeys
		(AllInstances_Schema (Establish_PackageToSchema uml))).
	{
		rewrite Hs.
		unfold Build_PackageToSchema.
		simpl.
		unfold Establish_AssocToFKey.

		apply (LiftPastFlatMaps 
			Association 
			ForeignKey
			a fk
			(fun assoc : Association =>
				match Dereference_Class uml (Project_Association_source assoc) with
				| Some c1 =>
					match
						Dereference_Class uml (Project_Association_destination assoc)
					with
					| Some c2 =>
						match Project_Class_kind c1 with
						| PERSISTENT =>
							match Project_Class_kind c2 with
							| PERSISTENT => Build_AssocToFKey c1 c2 assoc :: nil
							| OTHER => nil
							end
						| OTHER => nil
						end
					| None => nil
					end
				| None => nil
				end) (Filter_Association (Project_Package_elements p))).
		case_eq (Dereference_Class uml (Project_Association_source a)).
			intros. rewrite H in H8eq.
			case_eq (Dereference_Class uml (Project_Association_destination a)).
				intros. rewrite H0 in H11eq.
				case_eq (Project_Class_kind c).
					intros.
					case_eq (Project_Class_kind c0).
						intros.
						simpl.
						left.
						rewrite Hfk.
						congruence.

					congruence.
				congruence.
			congruence.
		congruence.
		assert (p = p). reflexivity.
		apply (UML.Consistent_Dereference_Association_namespace AssociationOIDsAreUnique uml p a).

		unfold PackageToSchema in H2.
		destruct H2 as [H2a H2b].
		assumption.

		(* In a (AllInstances_Association uml) *)
		assumption.

		(* Some p = Dereference_Association_namespace uml a *)
		assumption.
	}
	{  (* In s (AllInstances_Schema (Establish_PackageToSchema uml)) *)
		unfold AllInstances_Schema.
		unfold Establish_PackageToSchema.
		simpl Content.
		apply (LiftPastMaps Package Schema p s (Build_PackageToSchema uml) (AllInstances_Package uml)).
		rewrite Hs.
		reflexivity.

		unfold PackageToSchema in H2.
		destruct H2 as [H2a H2b].
		assumption.
	}
}
Qed.

Lemma TablesContainColumnsInRDBMS:
	forall uml : UML,
	forall rdbms : RDBMS,
		rdbms = Establish_PackageToSchema (uml : UML) ->
	forall t1 t2 : Table, forall c : Column,
		In t1 (AllInstances_Table rdbms) /\ In t2 (AllInstances_Table rdbms) /\
		In c (Project_Table_columns t1) /\
		In c (Project_Table_columns t2) ->
		t1 = t2.
Proof.
{
	intros uml rdbms.
	intro H1eq.
	intros t1 t2 c0.
	rewrite H1eq.
	intro HA.
	destruct HA as [HA1 HA2]; destruct HA2 as [HA2 HA3]; destruct HA3 as [HA3 HA4].
	apply (TableOIDsAreUnique uml rdbms).
	split.
	exact H1eq.
	rewrite H1eq.
	split.
	exact HA1.
	exact HA2.

	(* follow table t1/t2 to their originating class c1/c2 *)
	unfold AllInstances_Table in HA1, HA2.
	unfold AllInstances_Schema in HA1, HA2.
	unfold Establish_PackageToSchema in HA1, HA2.
	simpl Content in HA1, HA2.
	apply (UnliftPastFlatMaps Schema Table t1 Project_Schema_tables (map (Build_PackageToSchema uml) (AllInstances_Package uml))) in HA1.
	apply (UnliftPastFlatMaps Schema Table t2 Project_Schema_tables (map (Build_PackageToSchema uml) (AllInstances_Package uml))) in HA2.
	destruct HA1 as [s1 HA1].
	destruct HA2 as [s2 HA2].
	destruct HA1 as [HA1a HA1b].
	destruct HA2 as [HA2a HA2b].
	apply (UnliftPastMaps Package Schema s1 (Build_PackageToSchema uml) (AllInstances_Package uml)) in HA1b.
	apply (UnliftPastMaps Package Schema s2 (Build_PackageToSchema uml) (AllInstances_Package uml)) in HA2b.
	destruct HA1b as [p1 HA1b].
	destruct HA2b as [p2 HA2b].
	destruct HA1b as [HA1b HA1c].
	destruct HA2b as [HA2b HA2c].
	rewrite HA1b in HA1a; rewrite HA2b in HA2a.
	simpl Project_Schema_tables in HA1a, HA2a.
	unfold Establish_ClassToTable in HA1a, HA2a.
	apply (UnliftPastFlatMaps Class Table t1 (fun c : Class =>
		 match Project_Class_kind c with
		 | PERSISTENT => Build_ClassToTable uml p1 c EmptyString :: nil
		 | OTHER => nil
		 end) (Filter_Class (Project_Package_elements p1))) in HA1a.
	apply (UnliftPastFlatMaps Class Table t2 (fun c : Class =>
		 match Project_Class_kind c with
		 | PERSISTENT => Build_ClassToTable uml p2 c EmptyString :: nil
		 | OTHER => nil
		 end) (Filter_Class (Project_Package_elements p2))) in HA2a.
	destruct HA1a as [c1 HA1a].
	destruct HA2a as [c2 HA2a].
	destruct HA1a as [HA1a HA1d].
	destruct HA2a as [HA2a HA2d].
	case_eq (Project_Class_kind c1); intro HA1e; rewrite HA1e in HA1a.
		case_eq (Project_Class_kind c2); intro HA2e; rewrite HA2e in HA2a.
			simpl in HA1a, HA2a.
			destruct HA1a, HA2a.
				rewrite <- H, <- H0.
				simpl Project_Table_oid; simpl Project_Table_OID_nat.

				(* follow column c0 from table t1/t2 to their originating association a3/a4 *)
				rewrite <- H in HA3; rewrite <- H0 in HA4.
				simpl Project_Table_columns in HA3, HA4.
				apply (SplitList Column c0 ({|
						Project_Column_oid := {| 
							Project_Column_OID_nat := Project_Class_OID_nat (Project_Class_oid c1) |};
						Project_Column_super := {| 
							Project_ModelElement_name := Project_Class_name c1 ++ "_tid"; 
							Project_ModelElement_kind := "" |};
						Project_Column_type := NUMBER;
						Project_Column_hasKeys := nil;
						Project_Column_hasForeignKeys := nil 
					|} :: Establish_AttributeToColumn c1 "" )(*++*)(
					Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p1))) ) in HA3.
				apply (SplitList Column c0 ({| 
							Project_Column_oid := {| Project_Column_OID_nat := Project_Class_OID_nat (Project_Class_oid c2) |};
						Project_Column_super := {| 
							Project_ModelElement_name := Project_Class_name c2 ++ "_tid"; 
							Project_ModelElement_kind := "" |};
						Project_Column_type := NUMBER;
						Project_Column_hasKeys := nil;
						Project_Column_hasForeignKeys := nil 
					|} :: Establish_AttributeToColumn c2 "")
					(Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p2)))) in HA4.
				simpl In in HA3, HA4.
				(* Seven combinations appear when creating columns c1 and c2, based on pattern 1 :: 2 ++ 3, we have:
					1&1, 1&2, 2&1, 2&2, 1&3, 3&1, 3&3 *)
				destruct HA3, HA4.
					destruct H1, H2.
						(* 1&1, Build_ClassToTable's column & Build_ClassToTable's column *)
						assert (DestroyColumn: forall x y, forall H: x = y, Project_Column_OID_nat (Project_Column_oid x) = Project_Column_OID_nat (Project_Column_oid y)).
							intros x y Hd1. rewrite Hd1. reflexivity.
						rewrite <- H2 in H1. apply (DestroyColumn {|
							Project_Column_oid := {| Project_Column_OID_nat := Project_Class_OID_nat (Project_Class_oid c1) |};
							Project_Column_super := {|
								Project_ModelElement_name := Project_Class_name c1 ++ "_tid";
								Project_ModelElement_kind := "" |};
							Project_Column_type := NUMBER;
							Project_Column_hasKeys := nil;
							Project_Column_hasForeignKeys := nil |} {|
							Project_Column_oid := {| Project_Column_OID_nat := Project_Class_OID_nat (Project_Class_oid c2) |};
							Project_Column_super := {|
								Project_ModelElement_name := Project_Class_name c2 ++ "_tid";
								Project_ModelElement_kind := "" |};
							Project_Column_type := NUMBER;
							Project_Column_hasKeys := nil;
							Project_Column_hasForeignKeys := nil |}) in H1.
						simpl Project_Column_OID_nat in H1; clear H2.
						congruence.

						(* 1&2: Build_ClassToTable's column & Establish_AttributeToColumn *)
						(* We must show that these two have always different OIDs *)
						unfold Establish_AttributeToColumn in H2.
						(*case_eq c2.
							intros.
							rewrite H3 in H2.
							case_eq l. intro. rewrite H4 in H2. case_eq o. intros. rewrite H5 in H2.*)
	(**)						  admit.  (* This case should elim somehow *)

						(* 2&1 Build_ClassToTable's column & Establish_AttributeToColumn *)
	(**)						  admit.  (* This case should elim somehow *)

						(* 2&2: Establish_AttributeToColumn & Establish_AttributeToColumn *)
	(**)						  admit.  (* This case should match certain columns *)

						(* 1&3: Build_ClassToTable's column & Establish_AssocToColumn *)
	(**)						  admit.  (* This case should match certain columns *)

						(* 3&1: Build_ClassToTable's column & Establish_AssocToColumn *)
	(**)						  admit.  (* This case should match certain columns *)

						(* 3&3 Establish_AssocToColumn & Establish_AssocToColumn *)

	(**)						  admit.  (* This case should match certain elements *)

					elim H0.
				elim H.
			elim H0.
		elim HA2a.
	elim HA1a.
}
Qed.

(********************************************************************)
(* The actual proof *)

(* ---------- AttributeToColumn ---------- *)

Lemma L_AttributeToColumn : 
	forall uml : UML,
	forall p' : UML.Package,
	forall c : UML.Class,
	forall t : RDBMS.Table,
	forall prefix : string,
		AttributeToColumn c t prefix.
Proof.
	clear PackageOIDsAreUnique ClassOIDsAreUnique AssociationOIDsAreUnique.
	clear ClassAttributeOIDsAreUnique ClassAssociationOIDsAreUnique.
	clear PackagesContainClasses PackagesContainAssociations.
	intros uml p'.
	fix FIX 1.
	intros c t prefix.
	destruct c as [oid super general attributes].
	split.
	{
		(* PrimitiveAttributeToColumn *)

		exists (Build_ClassToTable uml p' (Build_Class oid super general attributes) prefix).
		unfold Project_Class_attributes.
		intros an pn a H1.
		induction attributes as [| a' l IHl].
		{
			inversion H1.
		}
		intro HYP1eq.
		destruct H1 as [H2eq | H3].
		{
			rewrite H2eq.
			unfold Build_ClassToTable.
			unfold Project_Table_columns.
			unfold Establish_AttributeToColumn.
			unfold Project_Class_attributes.
			destruct (Project_Attribute_type a).
			{
				exact I.
			}
			intros HYP2eq.
			exists (match prefix with | "" => an | String _ _ => (prefix ++ "_" ++ an)%string end).
			exists (PrimitiveTypeToSqlType pn).
			exists (Build_PrimitiveAttributeToColumn a p prefix).
			split.
			{
				right.
				left.
				reflexivity.
			}
			split.
			{
				unfold Project_Column_name.
				simpl.
				rewrite HYP1eq.
				reflexivity.
			}
			split.
			{
				unfold Project_Column_name.
				simpl.
				rewrite HYP2eq.
				reflexivity.
			}
			split.
			{
				reflexivity.
			}
			reflexivity.
		}
		destruct (Project_Attribute_type a).
		{
			exact I.
		}
		intros HYP2eq.
		destruct (IHl H3 HYP1eq HYP2eq) as [cn_witness HYP3].
		exists cn_witness.
		destruct HYP3 as [sqltype_witness HYP4].
		exists sqltype_witness.
		destruct HYP4 as [cl_witness H4].
		exists cl_witness.
		destruct H4 as [H4 HYP5].
		split.
		{
			unfold Build_ClassToTable in H4.
			unfold Project_Table_columns in H4.

			(* 1 *)
			destruct H4 as [H5 | H4].
			{
				unfold Build_ClassToTable.
				unfold Project_Table_columns.
				left.
				unfold Project_Class_name.
				simpl.
				exact H5.
			}

			(* 2 *)
			apply (SplitList) in H4.
			destruct H4 as [H5 | H4].
			{
				unfold Build_ClassToTable.
				unfold Project_Table_columns.
				right.
				apply LeftExpandList.
				unfold Establish_AttributeToColumn in H5.
				apply (SplitList) in H5.
				destruct H5 as [H6 | H5].
				{
					unfold Establish_AttributeToColumn.
					apply LeftExpandList.
					simpl.
					case (Project_Attribute_type a').
					{
						intro c.
						exact H6.
					}
					intro p0.
					right.
					exact H6.
				}

				(* 3 *)
				apply (SplitList) in H5.
				destruct H5 as [H6 | H5].
				{
					unfold Establish_AttributeToColumn.
					apply RightExpandList.
					apply LeftExpandList.
					simpl.
					destruct (Project_Attribute_type a').
					{
						apply RightExpandList.
						exact H6.
					}
					exact H6.
				}

				(* 4 *)
				unfold Establish_AttributeToColumn.
				apply RightExpandList.
				apply RightExpandList.
				exact H5.
			}

			(* 5 *)
			unfold Build_ClassToTable.
			unfold Project_Table_columns.
			right.
			apply RightExpandList.
			exact H4.
		}
		destruct HYP5 as [HYP5 HYP6].
		destruct HYP6 as [HYP6 HYP7].
		split.
		{
			exact HYP5.
		}
		split.
		{
			exact HYP6.
		}
		exact HYP7.
	}
	split.
	{
		(* ComplexAttributeToColumn *)

		intros an.
		unfold Project_Class_attributes.
		induction attributes as [| a' l IHl].
		{
			exact I.
		}
		intro H3eq.
		split.
		{
			destruct (Project_Attribute_type a') as [tc | pdt].
			{
				exists (prefix ++ "_" ++ an)%string.
				exact (FIX tc t (prefix ++ "_" ++ an)%string).
		  }
			exact I.
		}
		exact IHl.
	}

	(* SuperAttributeToColumn *)

	unfold Project_Class_general.
	destruct general as [sc |].
	{
		exact (FIX sc t prefix).
	}
	exact I.
Qed.

(* ---------- Top_PackageToSchema ---------- *)

Lemma L_Top_PackageToSchema :
	forall uml : UML,
	forall rdbms : RDBMS,
		rdbms = Establish_PackageToSchema uml ->
		Top_PackageToSchema uml rdbms.
Proof.
	intros uml rdbms H1eq.
	rewrite H1eq.
	unfold Top_PackageToSchema.
	intros PackageToSchema_pn PackageToSchema_p H2eq H3eq.
	set (PackageToSchema_s := (Build_PackageToSchema uml PackageToSchema_p)).
	exists PackageToSchema_s.
	split.
	{
		unfold Establish_PackageToSchema.
		simpl.
		apply (LiftPastMaps 
			Package
			Schema
			PackageToSchema_p PackageToSchema_s
			(Build_PackageToSchema uml)
			(AllInstances_Package uml)).
		{
			subst PackageToSchema_s.
			reflexivity.
		}
		exact H2eq.
	}
	exact H3eq.
Qed.

(* ---------- Top_ClassToTable ---------- *)

Lemma L_Top_ClassToTable :
	forall uml : UML,
	forall rdbms : RDBMS,
		rdbms = Establish_PackageToSchema uml ->
		Top_ClassToTable uml rdbms.
Proof.
	intros uml rdbms H1eq.
	rewrite H1eq.
	unfold Top_ClassToTable.
	intro ClassToTable_p.
	set (ClassToTable_s_witness := (Build_PackageToSchema uml ClassToTable_p)).
	exists ClassToTable_s_witness.
	intros H2 ClassToTable_cn ClassToTable_prefix ClassToTable_c H4 H5eq H6eq H7eq.
	unfold PackageToSchema in H2.
	destruct H2 as [H2 H8].
	set (ClassToTable_t_witness := (Build_ClassToTable uml ClassToTable_p ClassToTable_c EmptyString)).
	exists ClassToTable_t_witness.	
	assert (ClassInPackage : In ClassToTable_c (Filter_Class (Project_Package_elements ClassToTable_p))).
	{
		apply (UML.Consistent_Dereference_Class_namespace ClassOIDsAreUnique uml ClassToTable_p ClassToTable_c).
		{
			exact H2.
		}
		{
			exact H4.
		}
		exact H5eq.
	}
	assert (TableInRDBMS : In ClassToTable_t_witness (AllInstances_Table rdbms)).
	{
		rewrite H1eq.
		unfold AllInstances_Table.
		apply (LiftPastFlatMaps 
			Schema 
			Table 
			ClassToTable_s_witness 
			ClassToTable_t_witness 
			Project_Schema_tables 
			(AllInstances_Schema (Establish_PackageToSchema uml))).
		{
			unfold ClassToTable_s_witness.
			unfold Build_PackageToSchema.
			simpl.
			unfold Establish_ClassToTable.

			apply (LiftPastFlatMaps 
				Class 
				Table
				ClassToTable_c ClassToTable_t_witness
				(fun c : Class =>
					match Project_Class_kind c with
					| PERSISTENT => Build_ClassToTable uml ClassToTable_p c EmptyString :: nil
					| OTHER => nil
					end)
				(Filter_Class (Project_Package_elements ClassToTable_p))).
			{
				rewrite H6eq.
				left.
				subst ClassToTable_t_witness.
				reflexivity.
			}
			exact ClassInPackage.
		}
		simpl.
		apply (LiftPastMaps 
			Package 
			Schema
			ClassToTable_p 
			ClassToTable_s_witness
			(Build_PackageToSchema uml)
			(AllInstances_Package uml)).
		{
			subst ClassToTable_s_witness.
			reflexivity.
		}
		exact H2.
	}
	split.
	{  (* In ClassToTable_t_witness (AllInstances_Table rdbms) *)
		rewrite H1eq in TableInRDBMS.
		exact TableInRDBMS.
	}
	set (ClassToTable_cl_witness := RDBMS.Build_Column
		(RDBMS.Build_Column_OID (UML.Project_Class_OID_nat (UML.Project_Class_oid ClassToTable_c)))
		(RDBMS.Build_ModelElement ((UML.Project_Class_name ClassToTable_c) ++ "_tid") EmptyString)
		RDBMS.NUMBER
		nil
		nil).
	exists ClassToTable_cl_witness.
	set (ClassToTable_k_witness := RDBMS.Build_Key
		(RDBMS.Build_Key_OID (UML.Project_Class_OID_nat (UML.Project_Class_oid ClassToTable_c)))
		(RDBMS.Build_ModelElement ((UML.Project_Class_name ClassToTable_c) ++ "_pk") EmptyString)
		((RDBMS.Build_Column_OID (UML.Project_Class_OID_nat (UML.Project_Class_oid ClassToTable_c))) :: nil)).
	exists ClassToTable_k_witness.
	split.
	{  (* Project_Table_name ClassToTable_t_witness = ClassToTable_cn *)
		unfold ClassToTable_t_witness.
		unfold Build_ClassToTable.
		unfold Project_Table_name.
		simpl Project_Table_super.
		simpl.
		exact H7eq.
	}
	split.
	{  (* Some ClassToTable_s_witness = Dereference_Table_schema rdbms ClassToTable_t_witness *)
		assert (TheseSchemasContainTables: forall s1 s2 : Schema,
			forall t : Table,
				In s1 (AllInstances_Schema rdbms) /\ In s2 (AllInstances_Schema rdbms) /\
				In t (Project_Schema_tables s1) /\
				In t (Project_Schema_tables s2) ->
				s1 = s2).
		{
			intros s1 s2 t H9.
			apply (SchemasContainTables uml rdbms s1 s2 t).
			split.
			{
				exact H1eq.
			}
			exact H9.
		}
		assert (TheseTableOIDsAreUnique: forall t1 t2,
			In t1 (AllInstances_Table rdbms) /\ In t2 (AllInstances_Table rdbms) /\
			((beq_nat (Project_Table_OID_nat (Project_Table_oid t1))
			(Project_Table_OID_nat (Project_Table_oid t2))) = true) ->
			t1 = t2).
		{
			intros t1 t2 H9.
			destruct H9 as [H9 H10].
			destruct H10 as [H10 H11].
			apply (TableOIDsAreUnique uml rdbms t1 t2).
			{
				split.
				{
					exact H1eq.
				}
				split.
				{
					exact H9.
				}
				exact H10.
			}
			apply (beq_nat_true (Project_Table_OID_nat (Project_Table_oid t1)) 
				(Project_Table_OID_nat (Project_Table_oid t2))).
			exact H11.
		}
		rewrite H1eq in TheseSchemasContainTables.
		rewrite H1eq in TheseTableOIDsAreUnique.
		apply (Consistent_Dereference_Table_schema
			(Establish_PackageToSchema uml) 
			ClassToTable_s_witness 
			ClassToTable_t_witness 
			TheseSchemasContainTables 
			TheseTableOIDsAreUnique).
		{
			destruct H8 as [H8a H8b].
			exact H8a.
		}
		{
			rewrite H1eq in TableInRDBMS.
			exact TableInRDBMS.
		}
		unfold ClassToTable_s_witness.
		unfold Build_PackageToSchema.
		simpl.
		unfold Establish_ClassToTable.
		apply (LiftPastFlatMaps 
			Class 
			Table
			ClassToTable_c ClassToTable_t_witness
			(fun c : Class =>
				match Project_Class_kind c with
				| PERSISTENT => Build_ClassToTable uml ClassToTable_p c EmptyString :: nil
				| OTHER => nil
				end)
			(Filter_Class (Project_Package_elements ClassToTable_p))).
		{
			rewrite H6eq.
			left.
			subst ClassToTable_t_witness.
			reflexivity.
		}
		exact ClassInPackage.
	}  
	split.
	{  (* In ClassToTable_cl_witness (Project_Table_columns ClassToTable_t_witness) *)
		unfold ClassToTable_t_witness.
		unfold Build_ClassToTable.
		left.
		subst ClassToTable_cl_witness.
		reflexivity.
	}
	split.
	{  (* Some ClassToTable_k_witness = Project_Table_hasKey ClassToTable_t_witness *)
		unfold ClassToTable_t_witness.
		unfold Build_ClassToTable.
		subst ClassToTable_k_witness.
		simpl Project_Table_hasKey.
		reflexivity.
	}
	split.
	{  (* Project_Column_name ClassToTable_cl_witness = (Project_Class_name ClassToTable_c ++ "_tid")%string *)
		unfold ClassToTable_cl_witness.
		unfold Project_Column_name.
		simpl Project_ModelElement_name.
		reflexivity.
	}
	split.
	{  (* Project_Column_type ClassToTable_cl_witness = NUMBER *)
		unfold ClassToTable_cl_witness.
		simpl.
		reflexivity.
	}
	unfold ClassToTable_k_witness.
	unfold ClassToTable_cl_witness.
	split.
	{  (* In (Project_Column_oid ClassToTable_cl_witness) (Project_Key_columns ClassToTable_k_witness) *)
		simpl.
		left.
		reflexivity.
	}
	split.
	{
		(* (RDBMS.Project_Key_name ClassToTable_k) = (ClassToTable_cn ++ "_pk")%string *)
		unfold Project_Key_name.
		rewrite H7eq.
		simpl Project_ModelElement_name.
		reflexivity.
	}
	split.
	{
		(* In (Some ClassToTable_cl_witness) (Dereference_Key_column rdbms ClassToTable_k_witness) *)
		simpl.
		left.
		unfold Dereference_Column.
		unfold Find_Column; simpl.
		apply eq_sym.
		apply (WeakLiftPastFind Column ClassToTable_cl_witness (fun oid' : Column =>
			beq_nat (Project_Column_OID_nat (Project_Column_oid oid'))
					  (Project_Class_OID_nat (Project_Class_oid ClassToTable_c)))
			(AllInstances_Column (Establish_PackageToSchema uml))).
		{
			unfold ClassToTable_cl_witness.
			apply beq_nat_true_iff.
			reflexivity.
		}
		{
			intros cl H9 H10eq.
			apply beq_nat_true_iff in H10eq.
			apply (ColumnOIDsAreUnique uml rdbms ClassToTable_cl_witness cl).
			repeat split.
			exact H1eq.
			unfold AllInstances_Column.
			apply (LiftPastFlatMaps Table Column ClassToTable_t_witness ClassToTable_cl_witness Project_Table_columns (AllInstances_Table rdbms)).
			{  (* In ClassToTable_cl_witness (Project_Table_columns ClassToTable_t_witness) *)
				unfold ClassToTable_t_witness.
				unfold Build_ClassToTable.
				left.
				subst ClassToTable_cl_witness.
				reflexivity.
			}
			{  (* In ClassToTable_t_witness (AllInstances_Table rdbms) *)
				assumption.
			}
			{  (* In cl (AllInstances_Column rdbms) *)
				rewrite H1eq; assumption.
			}
			unfold ClassToTable_cl_witness.
			rewrite H10eq.
			reflexivity.
		}
		{  (* In ClassToTable_cl_witness (AllInstances_Column (Establish_PackageToSchema uml)) *)
			unfold AllInstances_Column.
			rewrite <- H1eq.
			apply (LiftPastFlatMaps Table Column ClassToTable_t_witness ClassToTable_cl_witness Project_Table_columns (AllInstances_Table rdbms)).
			{  (* In ClassToTable_cl_witness (Project_Table_columns ClassToTable_t_witness) *)
				unfold ClassToTable_t_witness.
				unfold Build_ClassToTable.
				left.
				subst ClassToTable_cl_witness.
				reflexivity.
			}
			{  (* In ClassToTable_t_witness (AllInstances_Table rdbms) *)
				assumption.
			}
		}
	}
	{
		(* (ClassToTable_prefix = "" -> AttributeToColumn ClassToTable_c ClassToTable_t_witness ClassToTable_prefix) *)
		intro H3eq.
		rewrite H3eq.
		apply (L_AttributeToColumn uml ClassToTable_p ClassToTable_c).
	}
Qed.

(* ---------- Top_AssocToFKey ---------- *)

Lemma L_Top_AssocToFKey :
	forall uml : UML,
	forall rdbms : RDBMS,
		rdbms = Establish_PackageToSchema uml ->
		Top_AssocToFKey uml rdbms.
Proof.
	intros uml rdbms H1eq.
	rewrite H1eq.
	unfold Top_AssocToFKey.
	intros p sc dc pKey.
	set (srcTbl_witness := (Build_ClassToTable uml p sc EmptyString)).
	set (destTbl_witness := (Build_ClassToTable uml p dc EmptyString)).
	set (s_witness := (Build_PackageToSchema uml p)).
	exists srcTbl_witness, destTbl_witness, s_witness.
	intros H2 H3 H4 H5.
	intros a H6 an scn dcn.
	intros H6eq H7eq H8eq H9eq H10eq H11eq H12eq H13eq.
	set (fkn := (scn ++ "_" ++ an ++ "_" ++ dcn)%string).
	set (fcn := (fkn ++ "_tid")%string).
	set (fk := Build_AssocToFKey sc dc a).
	set (fc := Build_AssocToColumn sc dc a).
	exists fk.
	split.

	assert (Hs_witness : s_witness = Build_PackageToSchema uml p). unfold s_witness. reflexivity.
	rewrite <- H1eq.
	apply (ForeignKeyInRDBMS uml rdbms H1eq p s_witness Hs_witness H2 a H6 H6eq sc dc H8eq H9eq H11eq H12eq fk).
	reflexivity.

	exists fc, fkn, fcn.
	split.
	split.
	{  (* Some s_witness = Dereference_ForeignKey_schema (Establish_PackageToSchema uml) fk *)
		(* Backward containment reference => reduce to forward direction, which is then easy to proof. *)

		assert (ForeignKeyOIDsAreUniqueInRDBMS: forall fk1 fk2 : ForeignKey, 
			In fk1 (AllInstances_ForeignKey rdbms) /\ In fk2 (AllInstances_ForeignKey rdbms) /\
			((beq_nat (Project_ForeignKey_OID_nat (Project_ForeignKey_oid fk1))
			(Project_ForeignKey_OID_nat (Project_ForeignKey_oid fk2))) = true) ->
			fk1 = fk2).
		{
			intros.
			destruct H as [Ha Hb].
			destruct Hb as [Hb Hc].
			apply beq_nat_true_iff in Hc.
			apply (ForeignKeyOIDsAreUnique uml rdbms).
			repeat split.
			assumption.
			assumption.
			assumption.
			assumption.
		}

		rewrite <- H1eq.
		apply (Consistent_Dereference_ForeignKey_schema
			rdbms 
			s_witness 
			fk 
			(SchemasContainForeignKeysInRDBMS uml rdbms H1eq)
			ForeignKeyOIDsAreUniqueInRDBMS).

		{  (* In s_witness (AllInstances_Schema rdbms) *)
			assert (Hs_witness : s_witness = Build_PackageToSchema uml p). unfold s_witness. reflexivity.
			apply (SchemaInRDBMS uml rdbms H1eq p s_witness Hs_witness H2).
		}
		{  (* In fk (AllInstances_ForeignKey rdbms) *)
			assert (Hs_witness : s_witness = Build_PackageToSchema uml p). unfold s_witness. reflexivity.
			apply (ForeignKeyInRDBMS uml rdbms H1eq p s_witness Hs_witness H2 a H6 H6eq sc dc H8eq H9eq H11eq H12eq fk).
			reflexivity.
		}
		{  (* In fk (Project_Schema_foreignKeys s_witness) *)
			assert (Hs_witness : s_witness = Build_PackageToSchema uml p). unfold s_witness. reflexivity.
			apply (ForeignKeyInSchema uml rdbms H1eq p s_witness Hs_witness H2 a H6 H6eq sc dc H8eq H9eq H11eq H12eq fk).
			reflexivity.
		}
	}
	split.
	{  (* Project_ForeignKey_name fk = fkn *)
		unfold fk.
		unfold Build_AssocToFKey.
		unfold Project_ForeignKey_name.
		simpl. unfold fkn.
		rewrite <- H10eq, <- H7eq, <- H13eq.
		trivial.
	}
	split.
	{  (* Some srcTbl_witness = Dereference_ForeignKey_owner (Establish_PackageToSchema uml) fk *)
		(* Forward non-containment reference => get to the point where the Table_OID is defined on both sides of the association. *)

		(* Find the table t that is referenced by the given foreign key fk and then resolved. *)
		unfold Dereference_ForeignKey_owner.
		unfold Dereference_Table.
		unfold Find_Table.
		apply (WeakLiftPastFind Table srcTbl_witness (fun oid' : Table =>
			beq_nat (Project_Table_OID_nat (Project_Table_oid oid'))
			  (Project_Table_OID_nat (Project_ForeignKey_owner fk)))
		  (AllInstances_Table (Establish_PackageToSchema uml))).
		apply beq_nat_true_iff.
		reflexivity.

		(* Now show that srcTable_witness just has that Table_OID of t defined. *)
		intros t Ht1 Ht2.
		Lemma ResolveSrcTbl: forall {uml : UML} {rdbms : RDBMS}
			{srcTbl : Table} {t : Table} {fk : ForeignKey} {sc dc : Class} {p : Package} {a : Association}
			(srcTbl_witness : srcTbl = Build_ClassToTable uml p sc EmptyString) 
			(fk_witness : fk = Build_AssocToFKey sc dc a)
			(H1eq : rdbms = Establish_PackageToSchema uml)
			(H3: ClassToTable uml (Establish_PackageToSchema uml) sc srcTbl)
			(Ht1: In t (AllInstances_Table (Establish_PackageToSchema uml)))
			(Ht2: beq_nat (Project_Table_OID_nat (Project_Table_oid t)) (Project_Table_OID_nat (Project_ForeignKey_owner fk)) = true),

			srcTbl = t.
		{  Proof.
			intros.
			apply beq_nat_true_iff in Ht2.
			apply (TableOIDsAreUnique uml rdbms srcTbl t).
			split. assumption. split.

			unfold ClassToTable in H3.
			destruct H3 as [H3a H3b].
			destruct H3b as [H3b H3c].
			rewrite H1eq.
			assumption.

			rewrite H1eq.
			assumption.

			rewrite Ht2.
			rewrite srcTbl_witness; unfold Build_ClassToTable; simpl Project_Table_oid.
			rewrite fk_witness; unfold Build_AssocToFKey; simpl Project_Table_OID_nat.
			reflexivity.
		}  Qed.
		assert (Hs: srcTbl_witness = Build_ClassToTable uml p sc EmptyString). trivial.
		assert (Hf: fk = Build_AssocToFKey sc dc a). trivial.
		apply (ResolveSrcTbl Hs Hf H1eq H3 Ht1 Ht2).
		{  (* In srcTbl_witness (AllInstances_Table rdbms) *)
			unfold ClassToTable in H3.
			destruct H3 as [H3a H3b].
			destruct H3b as [H3b H3c].
			assumption.
		}
	}
	split.
	{  (* In (Some fc) (Dereference_ForeignKey_columns (Establish_PackageToSchema uml) fk) *)
		(* Forward non-containment reference => get to the point where the Column_OID is defined on both sides of the association. *)

		(* Find the column c that is referenced by the given foreign key fk and then resolved. *)
		unfold Dereference_ForeignKey_column.
		apply (LiftPastMaps Column_OID (option Column) (Project_Column_oid fc) (Some fc) (fun oid : Column_OID =>
				Dereference_Column (Establish_PackageToSchema uml) oid)
			(Project_ForeignKey_columns fk)).
		unfold Dereference_Column.
		unfold Find_Column.
		apply (WeakLiftPastFind Column fc (fun oid' : Column =>
			beq_nat (Project_Column_OID_nat (Project_Column_oid oid'))
					  (Project_Column_OID_nat (Project_Column_oid fc)))
			(AllInstances_Column (Establish_PackageToSchema uml))).
		apply beq_nat_true_iff.
		reflexivity.

		(* Now show that c just has that Column_OID of fc defined. *)
		intros c Hc1 Hc2.
		Lemma ResolveColumn: forall {uml : UML} {rdbms : RDBMS}
			{srcTbl : Table} {s : Schema} {fc c : Column} {sc dc : Class} {p : Package} {a : Association}
			(srcTbl_witness : srcTbl = Build_ClassToTable uml p sc EmptyString) 
			(fc_witness : fc = Build_AssocToColumn sc dc a)
			(H1eq : rdbms = Establish_PackageToSchema uml)
			(H2: PackageToSchema uml (Establish_PackageToSchema uml) p s)
			(H3: ClassToTable uml (Establish_PackageToSchema uml) sc srcTbl)
			(H6: In a (AllInstances_Association uml))
			(H6eq: Some p = Dereference_Association_namespace uml a)
			(H8eq: Dereference_Class uml (Project_Association_source a) = Some sc)
			(H9eq: Project_Class_kind sc = PERSISTENT)
			(H11eq: Dereference_Class uml (Project_Association_destination a) = Some dc)
			(H12eq: Project_Class_kind dc = PERSISTENT)
			(Hc1: In c (AllInstances_Column (Establish_PackageToSchema uml)))
			(Hc2: beq_nat (Project_Column_OID_nat (Project_Column_oid c)) (Project_Column_OID_nat (Project_Column_oid fc)) = true),

			fc = c.
		{  Proof.
			intros.
			apply beq_nat_true_iff in Hc2.
			apply (ColumnOIDsAreUnique uml rdbms fc c).
			split. assumption. split. 

			(* In fc (AllInstances_Column rdbms) *)
			rewrite H1eq.
			unfold AllInstances_Column.
			apply (LiftPastFlatMaps Table Column srcTbl fc Project_Table_columns
				(AllInstances_Table (Establish_PackageToSchema uml))).
			rewrite srcTbl_witness.
			unfold Build_ClassToTable.
			simpl Project_Table_columns.
			apply (RightExpandList Column fc ({|
				Project_Column_oid := {| 
					Project_Column_OID_nat := Project_Class_OID_nat (Project_Class_oid sc) |};
				Project_Column_super := {| 
					Project_ModelElement_name := Project_Class_name sc ++ "_tid"; 
					Project_ModelElement_kind := "" |};
				Project_Column_type := NUMBER;
				Project_Column_hasKeys := nil;
				Project_Column_hasForeignKeys := nil |}
				:: Establish_AttributeToColumn sc "")
					(Establish_AssocToColumn uml
					  (Filter_Association
						  (Project_Package_elements p)))).
			unfold Establish_AssocToColumn.
			apply (LiftPastFlatMaps Association Column a fc (fun a0 : Association =>
				match Dereference_Class uml (Project_Association_source a0) with
				| Some c1 =>
					 match
						Dereference_Class uml (Project_Association_destination a0)
					 with
					 | Some c2 =>
						  match Project_Class_kind c1 with
						  | PERSISTENT =>
								match Project_Class_kind c2 with
								| PERSISTENT => Build_AssocToColumn c1 c2 a0 :: nil
								| OTHER => nil
								end
						  | OTHER => nil
						  end
					 | None => nil
					 end
				| None => nil
				end) (Filter_Association (Project_Package_elements p))).
			rewrite H8eq.
			rewrite H11eq.
			rewrite H9eq.
			rewrite H12eq.
			simpl.
			left.
			rewrite fc_witness.
			reflexivity.

			(* In a (Filter_Association (Project_Package_elements p)) *)
			apply (Consistent_Dereference_Association_namespace AssociationOIDsAreUnique uml p a).

			unfold PackageToSchema in H2.
			destruct H2 as [H2a H2b].
			assumption.
			assumption.
			assumption.

			(* In srcTbl_witness (AllInstances_Table rdbms) *)
			unfold ClassToTable in H3.
			destruct H3 as [H3a H3b].
			destruct H3b as [H3b H3c].
			assumption.

			(* In c (AllInstances_Column rdbms) *)
			rewrite H1eq.
			assumption.

			congruence.
		} Qed.
		assert (Hs: srcTbl_witness = Build_ClassToTable uml p sc EmptyString). trivial.
		assert (Hfc: fc = Build_AssocToColumn sc dc a). trivial.
		apply (ResolveColumn Hs Hfc H1eq H2 H3 H6 H6eq H8eq H9eq H11eq H12eq Hc1 Hc2).
		{  (* In fc (AllInstances_Column (Establish_PackageToSchema uml)) *)
			(* This goal has been created by one of the lifting lemmata *)
			(* TODO: Proof is just a copy from right above, and should better be factored out. *)
			unfold fc.
			unfold AllInstances_Column.
			apply (LiftPastFlatMaps Table Column srcTbl_witness fc Project_Table_columns 
				(AllInstances_Table (Establish_PackageToSchema uml))).
			unfold srcTbl_witness.
			unfold Build_ClassToTable.
			simpl Project_Table_columns.
			apply (RightExpandList Column fc ({|
				Project_Column_oid := {| 
					Project_Column_OID_nat := Project_Class_OID_nat (Project_Class_oid sc) |};
				Project_Column_super := {| 
					Project_ModelElement_name := Project_Class_name sc ++ "_tid"; 
					Project_ModelElement_kind := "" |};
				Project_Column_type := NUMBER;
				Project_Column_hasKeys := nil;
				Project_Column_hasForeignKeys := nil |}
				:: Establish_AttributeToColumn sc "") 
				(Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p)))).
			unfold Establish_AssocToColumn.
			apply (LiftPastFlatMaps Association Column a fc (fun a0 : Association =>
				match Dereference_Class uml (Project_Association_source a0) with
				| Some c1 =>
					 match
						Dereference_Class uml (Project_Association_destination a0)
					 with
					 | Some c2 =>
						  match Project_Class_kind c1 with
						  | PERSISTENT =>
								match Project_Class_kind c2 with
								| PERSISTENT => Build_AssocToColumn c1 c2 a0 :: nil
								| OTHER => nil
								end
						  | OTHER => nil
						  end
					 | None => nil
					 end
				| None => nil
				end) (Filter_Association (Project_Package_elements p))).
			rewrite H8eq.
			rewrite H11eq.
			rewrite H9eq.
			rewrite H12eq.
			simpl.
			left.
			reflexivity.

			(* In a (Filter_Association (Project_Package_elements p)) *)
			apply (Consistent_Dereference_Association_namespace AssociationOIDsAreUnique uml p a).

			unfold PackageToSchema in H2.
			destruct H2 as [H2a H2b].
			assumption.
			assumption.
			assumption.

			(* In srcTbl_witness (AllInstances_Table (Establish_PackageToSchema uml)) *)
			unfold ClassToTable in H3.
			destruct H3 as [H3a H3b].
			destruct H3b as [H3b H3c].
			assumption.
		}
		{  (* In (Project_Column_oid fc) (Project_ForeignKey_columns fk) *)
			(* This goal has been created by one of the lifting lemmata. *)
			unfold fc, Build_AssocToColumn; simpl Project_Column_oid.
			unfold fk, Build_AssocToFKey; simpl Project_ForeignKey_columns.
			simpl; left; reflexivity.
		}
	}
	split.
	{  (* Project_Column_name fc = fcn *)
		unfold fc.
		unfold Build_AssocToColumn.
		unfold Project_Column_name.
		simpl.
		unfold fcn, fkn.
		rewrite H10eq, H7eq, H13eq.
		trivial.
	}
	split.
	{  (* Project_Column_type fc = NUMBER *)
		unfold fc.
		unfold Build_AssocToColumn.
		simpl.
		reflexivity.
	}
	split.
	{  (* Some srcTbl = Dereference_Column_owner (Establish_PackageToSchema uml) fc *)
		(* Backward containment reference => reduce to forward direction, which is then easy to proof. *)

		assert (ColumnOIDsAreUniqueInRDBMS: forall c1 c2 : Column, 
			In c1 (AllInstances_Column rdbms) /\ In c2 (AllInstances_Column rdbms) /\
			((beq_nat (Project_Column_OID_nat (Project_Column_oid c1))
			(Project_Column_OID_nat (Project_Column_oid c2))) = true) ->
			c1 = c2).
		{
			intros.
			destruct H as [Ha Hb].
			destruct Hb as [Hb Hc].
			apply beq_nat_true_iff in Hc.
			apply (ColumnOIDsAreUnique uml rdbms).
			repeat split.
			assumption.
			assumption.
			assumption.
			assumption.
		}

		rewrite <- H1eq.
		apply (Consistent_Dereference_Column_owner
			rdbms 
			srcTbl_witness 
			fc 
			(TablesContainColumnsInRDBMS uml rdbms H1eq)
			ColumnOIDsAreUniqueInRDBMS).

		{  (* In srcTbl_witness (AllInstances_Table rdbms) *)
			unfold ClassToTable in H3.
			destruct H3 as [H3a H3b].
			destruct H3b as [H3b H3c].
			rewrite H1eq.
			assumption.
		}
		{  (* In fc (AllInstances_Column rdbms) *)
			unfold fc.
			rewrite H1eq.
			unfold Establish_PackageToSchema.
			unfold AllInstances_Column.
			apply (LiftPastFlatMaps 
				Table 
				Column 
				srcTbl_witness 
				fc 
				Project_Table_columns
				(AllInstances_Table (Establish_PackageToSchema uml))).
			unfold srcTbl_witness.
			unfold Build_ClassToTable.
			simpl.
			right.
			apply (RightExpandList Column fc (Establish_AttributeToColumn sc "")
				(Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p)))).
			unfold Establish_AssocToColumn.
			apply (LiftPastFlatMaps 
				Association 
				Column
				a fc
				(fun assoc : Association =>
					match Dereference_Class uml (Project_Association_source assoc) with
					| Some c1 =>
						match Dereference_Class uml (Project_Association_destination assoc) with
						| Some c2 =>
							match Project_Class_kind c1 with
							| PERSISTENT =>
								match Project_Class_kind c2 with
								| PERSISTENT => Build_AssocToColumn c1 c2 assoc :: nil
								| OTHER => nil
								end
							| OTHER => nil
							end
						| None => nil
						end
					| None => nil
					end) (Filter_Association (Project_Package_elements p))).
			rewrite H8eq.
			rewrite H11eq.
			rewrite H9eq.
			rewrite H12eq.
			unfold fc.
			simpl.
			left.
			congruence.

			(* In a (AllInstances_Association uml) *)
			apply (Consistent_Dereference_Association_namespace AssociationOIDsAreUnique uml p a).

			unfold PackageToSchema in H2.
			destruct H2 as [H2a H2b].
			assumption.
			assumption.
			assumption.

			(* In srcTbl_witness (AllInstances_Table (Establish_PackageToSchema uml)) *)
			unfold ClassToTable in H3.
			destruct H3 as [H3a H3b].
			destruct H3b as [H3b H3c].
			assumption.
		}
		{  (* In fc (Project_Table_columns srcTbl_witness) *)
			simpl. right.
			apply (RightExpandList Column fc (Establish_AttributeToColumn sc "")
				(Establish_AssocToColumn uml (Filter_Association (Project_Package_elements p)))).
			unfold srcTbl_witness, Build_ClassToTable; simpl Project_Table_columns.
			unfold Establish_AssocToColumn.
			apply (LiftPastFlatMaps Association Column a fc (fun a0 : Association =>
				match Dereference_Class uml (Project_Association_source a0) with
				| Some c1 =>
					match Dereference_Class uml (Project_Association_destination a0) with
					| Some c2 =>
						match Project_Class_kind c1 with
						| PERSISTENT =>
							match Project_Class_kind c2 with
							| PERSISTENT => Build_AssocToColumn c1 c2 a0 :: nil
							| OTHER => nil
							end
						| OTHER => nil
						end
					| None => nil
					end
				| None => nil
				end) (Filter_Association (Project_Package_elements p))).
			rewrite H8eq.
			rewrite H11eq.
			rewrite H9eq.
			rewrite H12eq.
			unfold fc, Build_AssocToColumn; simpl; left; trivial.

			(* In a (Filter_Association (Project_Package_elements p)) *)
			apply (Consistent_Dereference_Association_namespace AssociationOIDsAreUnique uml p a).

			unfold PackageToSchema in H2.
			destruct H2 as [H2a H2b].
			assumption.
			assumption.
			assumption.
		}
	}
	{  (* Dereference_ForeignKey_refersTo (Establish_PackageToSchema uml) fk = Some pKey *)
		unfold Dereference_ForeignKey_refersTo.
		unfold Dereference_Key.
		unfold Find_Key.
		apply (WeakLiftPastFind Key pKey (fun oid' : Key =>
			beq_nat (Project_Key_OID_nat (Project_Key_oid oid'))
					  (Project_Key_OID_nat (Project_ForeignKey_refersTo fk)))
			(AllInstances_Key (Establish_PackageToSchema uml))).
		apply beq_nat_true_iff.

		unfold destTbl_witness in H5.
		unfold Build_ClassToTable in H5.
		simpl Project_Table_hasKey in H5.
		assert (DestructSome: forall t : Type, forall x y : t, Some x = Some y -> x = y). intros. congruence.
		apply (DestructSome Key) in H5. 
		rewrite H5.
		unfold fk.
		unfold Build_AssocToFKey.
		reflexivity.

		(* Now show that destTable_witness just has that Table_OID of t defined. *)
		intros k Hk1 Hk2.
		assert (pKey = k).
		{
			apply beq_nat_true_iff in Hk2.
			apply (KeyOIDsAreUnique uml rdbms pKey k).
			split. assumption. split.
 
			unfold AllInstances_Key.
			apply (LiftPastFlatMaps Table Key destTbl_witness pKey (fun o : Table => 
				Filter_Key (Project_Table_hasKey o)) (AllInstances_Table rdbms)).
			unfold Filter_Key.
			rewrite <- H5.
			simpl; left; congruence.

			destruct H4 as [H4a H4b].
			destruct H4b as [H4b H4c].
			rewrite H1eq.
			assumption.

			rewrite H1eq.
			assumption.

			rewrite Hk2.
			unfold fk.
			unfold Build_AssocToFKey.
			(* Repeating what we've done above *)
			unfold destTbl_witness in H5.
			unfold Build_ClassToTable in H5.
			simpl Project_Table_hasKey in H5.
			assert (DestructSome: forall t : Type, forall x y : t, Some x = Some y -> x = y). intros. congruence.
			apply (DestructSome Key) in H5. 
			rewrite H5.
			reflexivity.
		}
		assumption.
		{  (* In pKey (AllInstances_Key rdbms) *)
			(* Repeating what we've done above *)
			unfold AllInstances_Key.
			apply (LiftPastFlatMaps Table Key destTbl_witness pKey (fun o : Table => 
				Filter_Key (Project_Table_hasKey o)) (AllInstances_Table (Establish_PackageToSchema uml))).
			unfold Filter_Key.
			rewrite <- H5.
			simpl; left; congruence.

			(* In destTbl_witness (AllInstances_Table (Establish_PackageToSchema uml)) *)
			(* Repeating what we've done above *)
			destruct H4 as [H4a H4b].
			destruct H4b as [H4b H4c].
			assumption.
		}
	}
	split.
	{  (* fkn = (scn ++ "_" ++ an ++ "_" ++ dcn)%string *)
		trivial.
	}
	{  (* fcn = (fkn ++ "_tid")%string *)
	  trivial.
	}
Qed.

(* ---------- Transformation ---------- *)

Theorem Transform :
	forall uml : UML, 
	{
		rdbms : RDBMS |
		Top_PackageToSchema uml rdbms /\
		Top_ClassToTable uml rdbms /\
		Top_AssocToFKey uml rdbms
	}.
Proof.
	intros uml.
	set (rdbms := Establish_PackageToSchema uml).
	exists rdbms.
	split.
	{
		apply (L_Top_PackageToSchema uml rdbms).
		subst rdbms.
		reflexivity.
	}
	split.
	{
		apply (L_Top_ClassToTable uml rdbms).
		subst rdbms.
		reflexivity.
	}
	apply (L_Top_AssocToFKey uml rdbms).
	subst rdbms.
	reflexivity.
Qed.

(********************************************************************
 Extract proof and run program on example model.
 ********************************************************************)
(* UML example model of a Media Library *)
(* Some proxy references are directly contained to foster structural recursion *)
Definition Build_UML_INTEGER := UML.Build_PrimitiveDataType 
	(UML.Build_PrimitiveDataType_OID 0) 
	(UML.Build_Classifier (UML.Build_PackageElement (UML.Build_ModelElement UML.PERSISTENT "INTEGER")))
.
Definition Build_UML_STRING := UML.Build_PrimitiveDataType 
	(UML.Build_PrimitiveDataType_OID 1) 
	(UML.Build_Classifier (UML.Build_PackageElement (UML.Build_ModelElement UML.PERSISTENT "STRING")))
.
Definition Build_UML_Library := UML.Build_Class 
	(UML.Build_Class_OID 0) 
	(UML.Build_Classifier (UML.Build_PackageElement (UML.Build_ModelElement UML.PERSISTENT "Library"))) 
	None 
	nil
.
Definition Build_UML_Author := UML.Build_Class 
	(UML.Build_Class_OID 4)
	(UML.Build_Classifier (UML.Build_PackageElement (UML.Build_ModelElement UML.PERSISTENT "Author"))) 
	None
	(	(UML.Build_Attribute (UML.Build_Attribute_OID 1) (UML.Build_ModelElement UML.PERSISTENT "name") (inr (*UML.Build_PrimitiveDataType_OID 1*)Build_UML_STRING) ) ::
		nil
	)
.
Definition Build_UML_Medium := UML.Build_Class 
	(UML.Build_Class_OID 1) 
	(UML.Build_Classifier (UML.Build_PackageElement (UML.Build_ModelElement UML.PERSISTENT "Medium"))) 
	None
	(	(UML.Build_Attribute (UML.Build_Attribute_OID 0) (UML.Build_ModelElement UML.PERSISTENT "author") (inl (*UML.Build_Class_OID 4*)Build_UML_Author) ) ::
		nil
	)
.
Definition Build_UML_Book := UML.Build_Class 
	(UML.Build_Class_OID 3) 
	(UML.Build_Classifier (UML.Build_PackageElement (UML.Build_ModelElement UML.PERSISTENT "Book"))) 
	(Some (*UML.Build_Class_OID 1*)Build_UML_Medium)
	(	(UML.Build_Attribute (UML.Build_Attribute_OID 0) (UML.Build_ModelElement UML.PERSISTENT "numberOfPages") (inr (*UML.Build_PrimitiveDataType_OID 0*)Build_UML_INTEGER) ) ::
		nil
	)
.
Definition Build_UML_NonPersistantClass := UML.Build_Class 
	(UML.Build_Class_OID 5) 
	(UML.Build_Classifier (UML.Build_PackageElement (UML.Build_ModelElement UML.OTHER "NonPersistantClass"))) 
	None 
	nil
.
Definition Build_UML_LibraryToMedium := UML.Build_Association 
	(UML.Build_Association_OID 0) 
	(UML.Build_PackageElement (UML.Build_ModelElement UML.PERSISTENT "LibraryToMedium")) 
	(UML.Build_Class_OID 0)
	(UML.Build_Class_OID 1)
.
Definition Build_UML_DVD := UML.Build_Class 
	(UML.Build_Class_OID 2) 
	(UML.Build_Classifier (UML.Build_PackageElement (UML.Build_ModelElement UML.PERSISTENT "DVD"))) 
	(Some (*UML.Build_Class_OID 1*)Build_UML_Medium)
	nil
.
Definition Build_UML_MediaLibrary := UML.Build
	(UML.Build_Package 
		(UML.Build_Package_OID 0) 
		(UML.Build_ModelElement UML.OTHER "myPackage") 
		(	(inl (inr Build_UML_INTEGER)) ::
			(inl (inr Build_UML_STRING)) ::
			(inl (inl Build_UML_Library)) ::
			(inl (inl Build_UML_Medium)) ::
			(inl (inl Build_UML_DVD)) ::
			(inl (inl Build_UML_Book)) ::
			(inl (inl Build_UML_Author)) ::
			(inl (inl Build_UML_NonPersistantClass)) ::
			(inr Build_UML_LibraryToMedium) ::
			nil
		) ::
		nil
	).

Eval compute in (Establish_PackageToSchema Build_UML_MediaLibrary).
Eval compute in (UML2RDBMS.Transform Build_UML_MediaLibrary).

End UML2RDBMS.

(********************************************************************
 Extract program from proof (see Curry-Howard Isomorphism).
 ********************************************************************)
Extraction Language  Ocaml. (*Haskell.*)
Set Extraction Optimize.
Set Extraction AccessOpaque.
Recursive Extraction Transform.
Recursive Extraction Build_UML_MediaLibrary.
